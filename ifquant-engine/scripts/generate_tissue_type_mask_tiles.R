#!/usr/bin/env Rscript

## Copyright (C) 2022 Julien Dorier and UNIL (University of Lausanne).
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <https://www.gnu.org/licenses/>.

##########################################
#parse command line options
##########################################
          
args=commandArgs(trailingOnly = TRUE)

library(optparse)

usage="
  %prog [options] tissue_segmentation_RData"

description="
Positional arguments:
\ttissue_segmentation_RData
\t\tRData file generated by tissue_segmentation.R."

epilogue="Notes:
 - This script will populate the output directory with tissue types tiles with name tile_<n>_<x>_<y>.png,
   with <n> the tile number (numbered by row), <x> and <y> the coordinates of the upper left corner.
   Each tile is a png image (tumor=red, stroma=green, other=blue, empty=black).
"

#default=NA => mandatory, default=NULL => optional.
option_list=list( 
    make_option(c("--tmpdir"), type="character", default=NULL,metavar="DIRNAME",
                help="Directory to save temporary images [Default R tempdir()].
\t\tConsider using /dev/shm/."),
    make_option(c("--nprocesses"), type="integer", default=1,metavar="N",
                help="Number of processes [default %default].
\t\tEach process will create one image of size tile-size*tile-size on temp directory"),
    make_option(c("--excluded-regions"), type="character", default=NULL,metavar="FILENAME",
                help="File with excluded regions (closed polygons).
\t\tComma separated format with header in the first row and 3 columns: id, x and y.
\t\tThis file can contain multiple polygons, each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point.
\t\tAll cells with center inside an excluded region will be ignored."),
    make_option(c("--tile-size"), type="integer", default=5000,metavar="N",
                help="Work with tiles of sizes NxN pixels [default %default]."),
    make_option(c("--output"), type="character", default=NA,metavar="DIRNAME",
                help="Output directory [mandatory].")
)


opt=parse_args(OptionParser(option_list=option_list,
                            usage=usage,
                            description=description,
                            epilogue=epilogue
                            ),positional_arguments=1,args=args)

##check all options are set, and print them
for(o in option_list)
{
    n=slot(o,"dest")
    f=c(slot(o,"short_flag"),slot(o,"long_flag"))
    f=paste(f[!is.na(f)],sep=",")
    if(!is.null(opt$options[[n]])) ##Default NULL => optional.
    {
        if(is.na(opt$options[[n]])) ##Default NA => mandatory
            stop("option ",f," is mandatory")
        ##check type
        if(typeof(opt$options[[n]])!=slot(o,"type"))
            stop("option ",f," must be ",slot(o,"type"))
        ##print
        if(slot(o,"action")!="store_true")
            cat(slot(o,"long_flag"),"=",opt$options[[n]],"\n",sep="")
        if(slot(o,"action")=="store_true"&&opt$options[[n]]==TRUE)
            cat(slot(o,"long_flag"),"\n",sep="")
    }
}
cat("positional arguments: ",paste(opt$args,collapse=" "),"\n",sep="")

tmpdir=opt$options[["tmpdir"]]
nprocesses=opt$options[["nprocesses"]]
input.excluded.regions=opt$options[["excluded-regions"]]
tile.size=opt$options[["tile-size"]]
outputdir=opt$options[["output"]]


##check
if(is.null(tmpdir))
{
    tmpdir=tempdir()
    cat("using tmpdir=",tmpdir,"\n",sep="")
}
if(!(is.finite(nprocesses)&nprocesses>0))
{
    stop("--nprocesses must be a positive integer")
}

##positional arguments
input.RData=opt$args[1]




dir.create(outputdir,showWarnings=FALSE,recursive=TRUE)

library(parallel)
library(data.table)
library(sp) #point.in.polygon
options(scipen=13)


##temporary directory
tmpdir=paste0(tempfile(pattern="tmp",tmpdir=tmpdir),"/")
dir.create(tmpdir,showWarnings=FALSE,recursive=TRUE)

##temporary directory cleaning
clean=function(){
    cat(paste0("[",format(Sys.time()),"] "),"removing",tmpdir,"\n")
    unlink(tmpdir, recursive=TRUE)
}
##erase temporary directory on error    
if(!interactive())
    options(error=function(){clean();quit(status = 1)})


############################################
##load
############################################

cat(paste0("[",format(Sys.time()),"] "),"loading",input.RData,"\n")
load(input.RData)

tissue.color=c(other="blue",stroma="green",tumor="red")
if(voronoi.cells.summary[,any(!tissue.type%in%names(tissue.color))])
{
    stop("Unexpected tissue type:",paste(voronoi.cells.summary[!tissue.type%in%names(tissue.color),unique(tissue.type)],collapse=", "))
}


############################################
##load excluded region
############################################

excluded.regions=data.table(id=integer(0))
if(!is.null(input.excluded.regions))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.excluded.regions,"\n")
    excluded.regions=fread(input.excluded.regions)
}

############################################
## flag cells to filter out 
############################################

voronoi.cells.summary[,excluded:=FALSE]
if(!is.null(input.excluded.regions))
{
    ##exclude points
    for(i in excluded.regions[,unique(id)])
        voronoi.cells.summary$excluded=voronoi.cells.summary$excluded|(point.in.polygon(voronoi.cells.summary$nucleus.x,voronoi.cells.summary$nucleus.y,excluded.regions[id==i,x],excluded.regions[id==i,y])!=0)

}

############################################
## add tissue type & exclusion status to voronoi.cells 
############################################

##add tissue.type
voronoi.cells[,tissue.type:=voronoi.cells.summary[voronoi.cells,tissue.type,on="cell.ID"]]
##add exclusion status
voronoi.cells[,excluded:=voronoi.cells.summary[voronoi.cells,excluded,on="cell.ID"]]


############################################
##tiles
############################################
tiles.x=lapply(0:floor(image.info$image.width.pixel/tile.size),function(i){
    c(x=i*tile.size,width=min(tile.size,image.info$image.width.pixel-i*tile.size))
})
tiles.y=lapply(0:floor(image.info$image.height.pixel/tile.size),function(i){
    c(y=i*tile.size,height=min(tile.size,image.info$image.height.pixel-i*tile.size))
})
##keep only tiles with finite sizes
tiles.x=tiles.x[sapply(tiles.x,function(x){x["width"]>0})]
tiles.y=tiles.y[sapply(tiles.y,function(x){x["height"]>0})]
##by rows
tiles=unlist(lapply(tiles.y,function(t.y){
    lapply(tiles.x,function(t.x){
        c(t.x,t.y)
    })
}),recursive=FALSE)

##add n
for(n in 1:length(tiles))
    tiles[[n]]=c(tiles[[n]],n=n)




############################################
##prepare input file for each tile
############################################
for(tile in tiles)
{
    w=tile["width"]
    h=tile["height"]
    tmp=voronoi.cells[excluded==FALSE&x>=tile["x"]&x<=tile["x"]+tile["width"]&y>=tile["y"]&y<=tile["y"]+tile["height"],unique(cell.ID)]
    filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],".rds")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    
    saveRDS(voronoi.cells[cell.ID%in%tmp],filename)
}

############################################
##create tissue type tiles
############################################
cl <- makeCluster(nprocesses,outfile="")
clusterEvalQ(cl, {
    library(data.table)
    setDTthreads(1)
    options(scipen=13)
})
clusterExport(cl, c("outputdir","tmpdir","tissue.color"))

invisible(parLapply(cl,tiles,function(tile){
    cat("Tile",tile[["n"]],": x=",tile[["x"]]," y=",tile[["y"]]," width=",tile[["width"]]," height=",tile[["height"]],"\n")

    ##load data
    input.filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],".rds")
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.filename,"\n")    
    voronoi.cells=readRDS(input.filename)
    cat(paste0("[",format(Sys.time()),"] "),"removing",input.filename,"\n")
    file.remove(input.filename)

    w=tile["width"]
    h=tile["height"]

    filename=paste0(outputdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],".png")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    png(filename,width=w,height=h)
    par(mar=c(0,0,0,0),bg = "black")
    plot(NA,xlim=c(-0.5,w-0.5),ylim=c(h-0.5,-0.5),xaxs="i",yaxs="i",xaxt="n",yaxt="n",type="n",xlab="",ylab="",bty="n")

    for(tt in names(tissue.color))
    {
        cat(paste0("[",format(Sys.time()),"] "),"Drawing ",tt," cells\n")
        ##insert NA between consecutive cells
        polygon(voronoi.cells[tissue.type==tt,.(x=c(x,NA),y=c(y,NA)),by=cell.ID][,.(x=x-tile["x"],y=y-tile["y"])],border=NA,col=tissue.color[tt])
    }

    dev.off()
}))

stopCluster(cl)

clean()
cat(paste0("[",format(Sys.time()),"] "),"Done\n")
