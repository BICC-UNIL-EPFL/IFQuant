#!/usr/bin/env Rscript

## Copyright (C) 2022 Julien Dorier and UNIL (University of Lausanne).
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <https://www.gnu.org/licenses/>.

##########################################
#parse command line options
##########################################
          
args=commandArgs(trailingOnly = TRUE)

library(optparse)

usage="
  %prog [options] merge_cells_RData tissue_segmentation_RData"

description="
Positional arguments:
\tmerge_cells_RData
\t\tRData file generated by merge_cells.R.
\ttissue_segmentation_RData
\t\tRData file generated by tissue_segmentation.R."

epilogue=""

#default=NA => mandatory, default=NULL => optional.
option_list=list( 
    make_option(c("--nprocesses"), type="integer", default=1,metavar="N",
                help="Max number of threads to use (only for data.table) [default %default]."),
    make_option(c("--thresholds"), type="character", default=NULL,metavar="FILENAME",
                help="File with channel thresholding information.
\t\tTab separated file with header in the first row and at least 4 columns:
\t\t * channel: channel number (0, 1, 2, ...).
\t\t * name: channel name (DAPI, CD15,... must correspond to metadata).
\t\t * score.type: score type
\t\t    should have the form <summary_statistic>.<region> with
\t\t    <summary_statistic>=mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050
\t\t     where q<n> is the n-th percentile and circular.q<n> is the n-th percentile of max in all directions.
\t\t    <region>=nucleus, extended.nucleus or around.nucleus
\t\t    e.g. mean.nucleus, median.extended.nucleus, q001.nucleus, q095.around.nucleus, circular.q010.around.nucleus
\t\t * threshold: numeric threshold. A cell is \"positive\" for a channel if its score is above threshold.
\t\tIf not specified: use thresholds saved in tissue_segmentation_RData.
\t\tWARNING: threshold for <tumor_marker> (e.g. CK) must be identical to the threshold used for tissue segmentation and stored in tissue_segmentation_RData."),
    make_option(c("--excluded-regions"), type="character", default=NULL,metavar="FILENAME",
                help="File with excluded regions (closed polygons).
\t\tComma separated format with header in the first row and 3 columns: id, x and y.
\t\tThis file can contain multiple polygons, each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point.
\t\tAll cells with center inside an excluded region will be ignored."),
    make_option(c("--coordinates"), type="character", default="slide",metavar="COORD",
                help="Coordinate system used for the output. Possible values:
\t\t * slide: slide coordinate system (all lengths in micron, (0,0) at the origin of the slide).
\t\t * image: image coordinate system (all lengths in pixels, (0,0) at the upper-left corner of the image)."),
    make_option(c("--output"), type="character", default=NA,metavar="FILENAME",
                help="Output file (.tsv tab separated format) [mandatory].")
)


opt=parse_args(OptionParser(option_list=option_list,
                            usage=usage,
                            description=description,
                            epilogue=epilogue
                            ),positional_arguments=2,args=args)

##check all options are set, and print them
for(o in option_list)
{
    n=slot(o,"dest")
    f=c(slot(o,"short_flag"),slot(o,"long_flag"))
    f=paste(f[!is.na(f)],sep=",")
    if(!is.null(opt$options[[n]])) ##Default NULL => optional.
    {
        if(is.na(opt$options[[n]])) ##Default NA => mandatory
            stop("option ",f," is mandatory")
        ##check type
        if(typeof(opt$options[[n]])!=slot(o,"type"))
            stop("option ",f," must be ",slot(o,"type"))
        ##print
        if(slot(o,"action")!="store_true")
            cat(slot(o,"long_flag"),"=",opt$options[[n]],"\n",sep="")
        if(slot(o,"action")=="store_true"&&opt$options[[n]]==TRUE)
            cat(slot(o,"long_flag"),"\n",sep="")
    }
}
cat("positional arguments: ",paste(opt$args,collapse=" "),"\n",sep="")

nprocesses=opt$options[["nprocesses"]]
input.thresholding=opt$options[["thresholds"]]
input.excluded.regions=opt$options[["excluded-regions"]]
coordinate.system=opt$options[["coordinates"]]
outputfile=opt$options[["output"]]


##check
if(!(is.finite(nprocesses)&nprocesses>0))
{
    stop("--nprocesses must be a positive integer")
}

##positional arguments
input_merge_cells.RData=opt$args[1]
input_tissue_segmentation.RData=opt$args[2]




dir.create(dirname(outputfile),showWarnings=FALSE,recursive=TRUE)
library(data.table)
library(sp) #point.in.polygon
options(scipen=13)

setDTthreads(nprocesses)



############################################
##load
############################################

cat(paste0("[",format(Sys.time()),"] "),"loading",input_merge_cells.RData,"\n")
load(input_merge_cells.RData)
image.info.tmp=image.info
metadata.tmp=metadata

cat(paste0("[",format(Sys.time()),"] "),"loading",input_tissue_segmentation.RData,"\n")
load(input_tissue_segmentation.RData)

##simple check
if(!identical(image.info.tmp,image.info))
{
    stop("inconsistent image.info in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}
if(!identical(metadata.tmp,metadata))
{
    stop("inconsistent metadata in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}

if(!is.null(input.thresholding))
{
    cat(paste0("[",format(Sys.time()),"] "),"loading",input.thresholding,"\n")
    metadata.channel.thresholding.tmp=read.table(input.thresholding,header=TRUE,stringsAsFactors=FALSE,sep="\t")
    metadata.channel.thresholding.tmp=metadata.channel.thresholding.tmp[order(metadata.channel.thresholding.tmp$channel),]
    rownames(metadata.channel.thresholding.tmp)=paste0("channel_",metadata.channel.thresholding.tmp$channel)
    ##check
    channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
    if(!all(metadata.channel.thresholding[channels,"channel"]==metadata.channel.thresholding.tmp[channels,"channel"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(metadata.channel.thresholding[channels,"name"]==metadata.channel.thresholding.tmp[channels,"name"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(c("score.type","threshold")%in%colnames(metadata.channel.thresholding.tmp)))
    {
        stop("Invalid",input.thresholding)
    }
    ##replace
    metadata.channel.thresholding=metadata.channel.thresholding.tmp
}

############################################
## check
############################################
if(is.null(nucleusFeatures.image)) ##i.e. 0 cells
{
    cat(paste0("[",format(Sys.time()),"] "),"0 cell found. Aborting...\n")
    channel.names=metadata[!metadata$channel%in%c(channel.dapi,channel.autofluorescence),"name"]
    output.table=data.frame(cell.ID=numeric(0),
                        nucleus.x=numeric(0),
                        nucleus.y=numeric(0),
                        tissue.type=character(0),
                        matrix(numeric(0),ncol=length(channel.names),nrow=0,dimnames=list(c(),channel.names)),
                        check.names=FALSE)

    cat(paste0("[",format(Sys.time()),"] "),"Saving results in",outputfile,"\n")
    write.table(output.table,file=outputfile,sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
    
    cat(paste0("[",format(Sys.time()),"] "),"Done\n")
    quit()
}

############################################
##load excluded region
############################################

excluded.regions=data.table(id=integer(0))
if(!is.null(input.excluded.regions))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.excluded.regions,"\n")
    excluded.regions=fread(input.excluded.regions)
}

############################################
## flag cells to filter out 
############################################

to.keep=rep(TRUE,nrow(nucleusFeatures.image[["shape"]]))
if(!is.null(input.excluded.regions))
{
    ##exclude points
    for(i in excluded.regions[,unique(id)])
        to.keep=to.keep&(point.in.polygon(nucleusFeatures.image[["shape"]][,"nucleus.x"],nucleusFeatures.image[["shape"]][,"nucleus.y"],excluded.regions[id==i,x],excluded.regions[id==i,y])==0)

}

############################################
## Evaluate score
############################################

data.score=NULL
for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    score.type=metadata.channel.thresholding[f,"score.type"]
    threshold=metadata.channel.thresholding[f,"threshold"]
    ##split score.type into summary statistic and region
    score.type.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",score.type)
    score.type.statistic=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",score.type)
    ##check
    if(!score.type.region%in%c("nucleus","extended.nucleus","around.nucleus"))
        stop("Invalid score type",score.type,". Accepted regions: nucleus, extended.nucleus or around.nucleus")
    if(!score.type.statistic%in%c("mean","median","q001","q005","q025","q075","q095","q099","circular.q005","circular.q010","circular.q025","circular.q050"))
        stop("Invalid score type ",score.type,". Accepted summary statistics: mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050")
    if(score.type.statistic=="median")score.type.statistic="q050"

    if(score.type.region=="nucleus")
    {
        data.score=cbind(data.score,nucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="extended.nucleus")
    {
        data.score=cbind(data.score,extendedNucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="around.nucleus")
    {
        data.score=cbind(data.score,aroundNucleusFeatures.image[[f]][,score.type.statistic])
    }
}
cols=metadata[!metadata$channel%in%c(channel.dapi,channel.autofluorescence),"name"]
colnames(data.score)=cols


set.seed(12734)

############################################
##export table of cells properties
############################################
##convert
if(coordinate.system=="slide")
{
    Precision=-floor(log10(convert.image.to.slide.length(1,image.info)))
    SquarePrecision=-floor(log10(convert.image.to.slide.length(1,image.info)**2))

    convert.position.x=function(x,image.info){round(convert.image.to.slide.position.x(x,image.info),digits=Precision)}
    convert.position.y=function(x,image.info){round(convert.image.to.slide.position.y(x,image.info),digits=Precision)}
    convert.length=function(x,image.info){round(convert.image.to.slide.length(x,image.info),digits=Precision)}
    convert.area=function(x,image.info){round(convert.image.to.slide.area(x,image.info),digits=SquarePrecision)}
}
if(coordinate.system=="image")
{
    Precision=-floor(log10(1))
    SquarePrecision=-floor(log10(1**2))
    convert.position.x=function(x,image.info){round(x,digits=Precision)}
    convert.position.y=function(x,image.info){round(x,digits=Precision)}
    convert.length=function(x,image.info){round(x,digits=Precision)}
    convert.area=function(x,image.info){round(x,digits=SquarePrecision)}
}

setkey(voronoi.cells.summary,cell.ID)
##check cell.ID corresponds to row index
if(!voronoi.cells.summary[,all(cell.ID==.I)])
  stop("problem with cell.ID")

output.table=data.frame(cell.ID=nucleusFeatures.image[["shape"]][,"cell.ID"],
                        nucleus.x=convert.position.x(nucleusFeatures.image[["shape"]][,"nucleus.x"],image.info),
                        nucleus.y=convert.position.y(nucleusFeatures.image[["shape"]][,"nucleus.y"],image.info),
                        voronoi.cells.summary[nucleusFeatures.image[["shape"]][,"cell.ID"],.(tissue.type)],
                        data.score,
                        stringsAsFactors=FALSE,check.names=FALSE)


cat(paste0("[",format(Sys.time()),"] "),"Saving results in",outputfile,"\n")
write.table(output.table[to.keep,],file=outputfile,sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)

cat(paste0("[",format(Sys.time()),"] "),"Done\n")
