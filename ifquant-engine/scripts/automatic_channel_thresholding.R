#!/usr/bin/env Rscript

## Copyright (C) 2022 Julien Dorier and UNIL (University of Lausanne).
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <https://www.gnu.org/licenses/>.

##########################################
#parse command line options
##########################################

args=commandArgs(trailingOnly = TRUE)

library(optparse)

usage="
  %prog [options] inputRData"

description="
Positional arguments:
\tinputRData
\t\tRData file generated by merge_cells.R."

epilogue="Notes:
 - Channel with tumor staining (e.g. CK) used for tissue classification is found by by matching the string \"tumor\" to column \"type\" of the panel metadata (metadata loaded from inputRData).
 - A file automatic_channel_thresholding.txt will be created (in the directory specified with --output).
   This file will be created from the content of --thresholds, but the column threshold will contain the new thresholds (or keep the original thresholds if automatic detection failed).
"

#default=NA => mandatory, default=NULL => optional.
option_list=list(
    make_option(c("--nprocesses"), type="integer", default=1,metavar="N",
                help="Max number of threads to use (only for data.table) [default %default]."),
    make_option(c("--transformation"), type="character", default="asinh",metavar="T",
                help="Apply transformation T on channel scores before threshold evaluation [default %default].
\t\t T=\"none\"
\t\t T=\"sqrt\"
\t\t T=\"log1p\"  (log(x+1))
\t\t T=\"asinh\" "),
    make_option(c("--excluded-regions"), type="character", default=NULL,metavar="FILENAME",
                help="File with excluded regions (closed polygons).
\t\tComma separated format with header in the first row and 3 columns: id, x and y.
\t\tThis file can contain multiple polygons, each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point.
\t\tAll cells with center inside an excluded region will be ignored."),
    make_option(c("--thresholds"), type="character", default=NA,metavar="FILENAME",
                help="File with channel thresholding information [mandatory].
\t\tTab separated file with header in the first row and 5 columns:
\t\t * channel: channel number (0, 1, 2, ...).
\t\t * name: channel name (DAPI, CD15,... must correspond to metadata).
\t\t * score.type: score type
\t\t    should have the form <summary_statistic>.<region> with
\t\t    <summary_statistic>=mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050
\t\t     where q<n> is the n-th percentile and circular.q<n> is the n-th percentile of max in all directions.
\t\t    <region>=nucleus, extended.nucleus or around.nucleus
\t\t    e.g. mean.nucleus, median.extended.nucleus, q001.nucleus, q095.around.nucleus, circular.q010.around.nucleus
\t\t * threshold: numeric threshold (default threshold). A cell is \"positive\" for a channel if its score is above threshold.
\t\t * automatic.thresholding.method: autmatic thresholding method (optional).
\t\t    comma separated list of method to use, with possible methods
\t\t    * none: use default threshold
\t\t    * bimodal: search for threshold separating bimodal distribution.
\t\t    * outliers: assume rare positive population and use threshold given by 3-rd quartile + 2 * interquartile range.
\t\t    If this column is not present, use \"bimodal\" for tumor staining and \"none\" for all other channels."),
    make_option(c("--output"), type="character", default=NA,metavar="DIRNAME",
                help="Output directory [mandatory].")
)


opt=parse_args(OptionParser(option_list=option_list,
                            usage=usage,
                            description=description,
                            epilogue=epilogue
                            ),positional_arguments=1,args=args)

##check all options are set, and print them
for(o in option_list)
{
    n=slot(o,"dest")
    f=c(slot(o,"short_flag"),slot(o,"long_flag"))
    f=paste(f[!is.na(f)],sep=",")
    if(!is.null(opt$options[[n]])) ##Default NULL => optional.
    {
        if(is.na(opt$options[[n]])) ##Default NA => mandatory
            stop("option ",f," is mandatory")
        ##check type
        if(typeof(opt$options[[n]])!=slot(o,"type"))
            stop("option ",f," must be ",slot(o,"type"))
        ##print
        if(slot(o,"action")!="store_true")
            cat(slot(o,"long_flag"),"=",opt$options[[n]],"\n",sep="")
        if(slot(o,"action")=="store_true"&&opt$options[[n]]==TRUE)
            cat(slot(o,"long_flag"),"\n",sep="")
    }
}
cat("positional arguments: ",paste(opt$args,collapse=" "),"\n",sep="")


nprocesses=opt$options[["nprocesses"]]
transformation=opt$options[["transformation"]]
input.excluded.regions=opt$options[["excluded-regions"]]
input.thresholding=opt$options[["thresholds"]]
outputdir=opt$options[["output"]]
##check
if(!(is.finite(nprocesses)&nprocesses>0))
{
    stop("--nprocesses must be a positive integer")
}

##positional arguments
input.RData=opt$args[1]


dir.create(outputdir,showWarnings=FALSE,recursive=TRUE)

library(data.table) 
library(sp) #point.in.polygon
options(scipen=13)

#nb threads for data.table
setDTthreads(nprocesses)




############################################
##load
############################################

cat(paste0("[",format(Sys.time()),"] "),"loading",input.RData,"\n")
load(input.RData)

cat(paste0("[",format(Sys.time()),"] "),"loading",input.thresholding,"\n")
metadata.channel.thresholding=read.table(input.thresholding,header=TRUE,stringsAsFactors=FALSE,sep="\t")
##check
if(!all(paste0("channel_",metadata.channel.thresholding$channel)%in%rownames(metadata)))
{
    stop("Invalid",input.thresholding," (invalid channel number)")
}
if(any(duplicated(metadata.channel.thresholding$channel)))
{
    stop("Invalid",input.thresholding," (duplicated channel number)")
}
rownames(metadata.channel.thresholding)=paste0("channel_",metadata.channel.thresholding$channel)
if(!all(metadata[rownames(metadata.channel.thresholding),"name"]==metadata.channel.thresholding$name))
{
    stop("Invalid",input.thresholding," (column name)")
}
if(!all(c("score.type","threshold")%in%colnames(metadata.channel.thresholding)))
{
    stop("Invalid",input.thresholding)
}
metadata.channel.thresholding=metadata.channel.thresholding[order(metadata.channel.thresholding$channel),]


input.ck=rownames(metadata)[sapply(strsplit(metadata$type,","),function(x){"tumor"%in%x})]
ck.channel.name=metadata[input.ck,"name"]
tumor_marker_present=(length(input.ck)>0)
if(tumor_marker_present==FALSE)
{
    ck.channel.name="MISSINGTUMORMARKER"
}

metadata.status=metadata.channel.thresholding[,c("channel","name")]
metadata.status$status="NOT_DONE"
##if missing, set default automatic.thresholding.method
if(!"automatic.thresholding.method"%in%colnames(metadata.channel.thresholding))
{
    metadata.channel.thresholding$automatic.thresholding.method="none"
    metadata.channel.thresholding[input.ck,"automatic.thresholding.method"]="bimodal"
}

channels=rownames(metadata)[!rownames(metadata)%in%c(input.dapi,input.autofluorescence)]

automatic.thresholding.method=lapply(metadata.channel.thresholding$automatic.thresholding.method,function(x){strsplit(x,",")[[1]]})
names(automatic.thresholding.method)=rownames(metadata.channel.thresholding)


############################################
##load excluded region
############################################

excluded.regions=data.table(id=integer(0))
if(!is.null(input.excluded.regions))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.excluded.regions,"\n")
    excluded.regions=fread(input.excluded.regions)
}


############################################
## check
############################################
if(is.null(nucleusFeatures.image)) ##i.e. 0 cells
{
    ##generate dummy ouput
    cat(paste0("[",format(Sys.time()),"] "),"0 cell found. Aborting...\n")
    cat(paste0("[",format(Sys.time()),"] "),ck.channel.name,"channel score distribution (quantiles=0%,1%,10%,50%,90%,99%,100%):",paste(quantile(0,probs=c(0,0.01,0.1,0.5,0.9,0.99,1)),collapse=","),"\n")
    threshold.ck.positive=metadata.channel.thresholding[input.ck,"threshold"]
    filename=paste0(outputdir,"/automatic_channel_thresholding_",tolower(ck.channel.name),".pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,8,6)
    plot(0,0,type="n",xlab="",ylab="",xaxt="n",yaxt="n")
    dev.off()

    ##status
    for(channel in rownames(metadata)[!rownames(metadata)%in%c(input.dapi,input.autofluorescence)&metadata.channel.thresholding[rownames(metadata),"automatic.thresholding.method"]!="none"])
    {
        metadata.status[channel,"status"]="FAILED"
    }
    if(tumor_marker_present)
        cat(paste0("[",format(Sys.time()),"] "),ck.channel.name,"threshold=",threshold.ck.positive,"\n")
    filename=paste0(outputdir,"/automatic_channel_thresholding_status.txt")
    write.table(metadata.status,file=filename,sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)


    ##thresholds
    filename=paste0(outputdir,"/automatic_channel_thresholding.txt")
    cat(paste0("[",format(Sys.time()),"] "),"Saving results in",filename,"\n")
    write.table(metadata.channel.thresholding[,colnames(metadata.channel.thresholding)!="automatic.thresholding.method"],file=filename,sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)

    cat(paste0("[",format(Sys.time()),"] "),"Done\n")
    quit()
}


############################################
## Evaluate score
############################################

data.score=nucleusFeatures.image[["shape"]][,c("cell.ID","nucleus.x","nucleus.y"),drop=FALSE]
for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    score.type=metadata.channel.thresholding[f,"score.type"]
    ##split score.type into summary statistic and region
    score.type.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",score.type)
    score.type.statistic=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",score.type)
    ##check
    if(!score.type.region%in%c("nucleus","extended.nucleus","around.nucleus"))
        stop("Invalid score type",score.type,". Accepted regions: nucleus, extended.nucleus or around.nucleus")
    if(!score.type.statistic%in%c("mean","median","q001","q005","q025","q075","q095","q099","circular.q005","circular.q010","circular.q025","circular.q050"))
        stop("Invalid score type ",score.type,". Accepted summary statistics: mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050")
    if(score.type.statistic=="median")score.type.statistic="q050"

    if(score.type.region=="nucleus")
    {
        data.score=cbind(data.score,nucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="extended.nucleus")
    {
        data.score=cbind(data.score,extendedNucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="around.nucleus")
    {
        data.score=cbind(data.score,aroundNucleusFeatures.image[[f]][,score.type.statistic])
    }
}
colnames(data.score)=c("cell.ID","nucleus.x","nucleus.y",rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])

############################################
## flag cells to filter out
############################################

to.keep=rep(TRUE,nrow(nucleusFeatures.image[["shape"]]))
if(!is.null(input.excluded.regions))
{
    ##exclude points
    for(i in excluded.regions[,unique(id)])
        to.keep=to.keep&(point.in.polygon(nucleusFeatures.image[["shape"]][,"nucleus.x"],nucleusFeatures.image[["shape"]][,"nucleus.y"],excluded.regions[id==i,x],excluded.regions[id==i,y])==0)

}


cat(paste0("[",format(Sys.time()),"] "),ck.channel.name,"channel score distribution (quantiles=0%,1%,10%,50%,90%,99%,100%):",paste(quantile(data.score[to.keep,input.ck],probs=c(0,0.01,0.1,0.5,0.9,0.99,1)),collapse=","),"\n")


############################################
## Automatic determination of thresholds (search for bimodal distribution)
############################################

tile.size.x=1500 #2000#round(image.info$image.width.pixel/3)
tile.size.y=1500 #2000#round(image.info$image.height.pixel/3)
overlap.x=tile.size.x/2
overlap.y=tile.size.y/2

tiles.x=lapply(0:ceiling((image.info$image.width.pixel-tile.size.x)/(tile.size.x-overlap.x)),function(i){
    c(x=i*(tile.size.x-overlap.x),width=tile.size.x)
})
tiles.y=lapply(0:ceiling((image.info$image.height.pixel-tile.size.y)/(tile.size.y-overlap.y)),function(i){
    c(y=i*(tile.size.y-overlap.y),height=tile.size.y)
})
##move last tile if outside image
tiles.x=lapply(tiles.x,function(t){
    t["x"]=max(0,min(t["x"],image.info$image.width.pixel-t["width"]))
    t["width"]=min(t["width"],image.info$image.width.pixel-t["x"])
    t
})
tiles.y=lapply(tiles.y,function(t){
    t["y"]=max(0,min(t["y"],image.info$image.height.pixel-t["height"]))
    t["height"]=min(t["height"],image.info$image.height.pixel-t["y"])
    t
})

##keep only tiles with finite sizes (larger than 10)
tiles.x=tiles.x[sapply(tiles.x,function(x){x["width"]>10})]
tiles.y=tiles.y[sapply(tiles.y,function(x){x["height"]>10})]
##by rows
tiles=unlist(lapply(tiles.y,function(t.y){
    lapply(tiles.x,function(t.x){
        c(t.x,t.y)
    })
}),recursive=FALSE)

##add n
for(n in 1:length(tiles))
    tiles[[n]]=c(tiles[[n]],n=n)

x.transfo=NULL
if(transformation=="none")
{
    x.transfo=function(x){(x)}
    x.inv.transfo=function(x){(x)}
}
if(transformation=="sqrt")
{
    x.transfo=function(x){sqrt(x)}
    x.inv.transfo=function(x){sign(x)*(x)**2}
}
if(transformation=="log1p")
{
    x.transfo=function(x){log(x+1)}
    x.inv.transfo=function(x){exp(x)-1}
}
if(transformation=="asinh")
{
    x.transfo=function(x){asinh(x)}
    x.inv.transfo=function(x){sinh(x)}
}

bw.min=0.01 #0.3
min.ncell.per.tile=500
min.max_min.ratio=1.1
min.threshold=1

set.seed(12734)

cat(paste0("[",format(Sys.time()),"] "),"automatic thresholds determination (bimodal)\n")
channels.bimodal=channels[sapply(channels,function(channel){"bimodal"%in%automatic.thresholding.method[[channel]]})]

thresholds.tmp=rbindlist(lapply(tiles,function(tile){
    ##cat(tile,"\n")
    ##aggressive filtering on sharpness
    idx=which(to.keep&nucleusFeatures.image[["shape"]][,"sharpness"]>5&nucleusFeatures.image[["shape"]][,"nucleus.x"]>=tile["x"]&nucleusFeatures.image[["shape"]][,"nucleus.y"]>=tile["y"]&nucleusFeatures.image[["shape"]][,"nucleus.x"]<tile["x"]+tile["width"]&nucleusFeatures.image[["shape"]][,"nucleus.y"]<tile["y"]+tile["height"])
    if(length(idx)<min.ncell.per.tile)return(NULL) #list(status="EMPTY",threshold=NA,ncells=length(idx))) ##at least min.ncell.per.tile cells
    data.score.tmp=data.score[idx,,drop=FALSE]
    rbindlist(lapply(channels.bimodal,function(channel){
        bw=max(bw.min,max(x.transfo(data.score.tmp[,channel]))/20)
        channel.name=metadata[channel,"name"]
        tmp=density(x.transfo(data.score.tmp[,channel]),bw=bw,n=1024)
        x=tmp$x
        y=tmp$y
        dy=c(NA,diff(y))
        maxloc=which(diff(sign(dy))== -2)
        ##adjust position (max between maxloc, maxloc-1, maxloc+1)
        maxloc=sapply(maxloc,function(m){
            ind=max(1,m-1):min(length(y):m+1)
            ind[which.max(y[ind])]
        })
        if(length(maxloc)==0)
            maxloc=c()
        minloc=which(diff(sign(dy))==2)
        ##adjust position (min between minloc, minloc-1, minloc+1)
        minloc=sapply(minloc,function(m){
            ind=max(1,m-1):min(length(y):m+1)
            ind[which.min(y[ind])]
        })
        if(length(minloc)==0)
            minloc=c()

        ##keep only min with x>x.transfo(min.threshold)
        minloc=minloc[x[minloc]>x.transfo(min.threshold)]
        ##remove max not followed by a min
        if(length(maxloc)>1)
            maxloc=maxloc[maxloc[-1]>=min(minloc)]

        ##keep only max with high enough density
        miny=0.1*quantile(y,0.95)
        maxloc=maxloc[y[maxloc]>miny]
        ##keep min between remaining maximums
        minloc=minloc[minloc>min(maxloc)&minloc<max(maxloc)]
        ##keep only lowest y value
        minloc=minloc[which.min(y[minloc])]
        max_min.ratio=min(y[maxloc])/y[minloc]
        if((length(maxloc)==2&&length(minloc)==1)&&max_min.ratio>min.max_min.ratio)
        {
            threshold=x.inv.transfo(x[minloc])
            npos=length(which(data.score.tmp[,channel]>threshold))
            nneg=nrow(data.score.tmp)-npos
            status="SUCCESS"
        }
        else
        {
            threshold=NA
            npos=NA
            nneg=NA
            status="FAILED"
        }

        return(data.table(channel,status=status,threshold=threshold,ncells=nrow(data.score.tmp),npos=npos,nneg=nneg,tile.n=tile["n"])) ##at least 10 points
    }))
}))

#########################

if(nrow(thresholds.tmp)==0)
    thresholds.tmp=data.table(channel=character(0),status=character(0),threshold=numeric(0),ncells=integer(0),npos=integer(0),nneg=integer(0),tile.n=integer(0))
##keep only successfull thresholds
fraction.success=thresholds.tmp[,.(f=sum(status=="SUCCESS")/.N),by=channel][data.table(channel=channels.bimodal),on="channel"]
thresholds.tmp=thresholds.tmp[status=="SUCCESS"]
for(ch in channels.bimodal)
{
    channel.name=metadata[ch,"name"]
    if(nrow(thresholds.tmp[channel==ch])>0)
    {
        metadata.channel.thresholding[ch,"threshold"]=thresholds.tmp[channel==ch,median(threshold,na.rm=TRUE)]
        metadata.status[ch,"status"]="SUCCESS"
        cat(paste0("[",format(Sys.time()),"] ")," ",channel.name," number(fraction) of tiles with threshold: ",nrow(thresholds.tmp[channel==ch]),"(",signif(100*fraction.success[channel==ch,f],3),"%), mad/median: ",thresholds.tmp[channel==ch,mad(x.transfo(threshold)/median(x.transfo(threshold)))]," \n",sep="")
        if(fraction.success[channel==ch,f]<0.1||nrow(thresholds.tmp[channel==ch])<5||thresholds.tmp[channel==ch,mad(x.transfo(threshold)/median(x.transfo(threshold)))]>0.2)
        {
            metadata.status[ch,"status"]="WARNING"
        }
    }
    if(nrow(thresholds.tmp[channel==ch])==0)#failed
    {
        cat(paste0("[",format(Sys.time()),"] ")," ",channel.name," failed\n",sep="")
        metadata.status[ch,"status"]="FAILED"
    }
}

## ########## Second pass: Automatic determination of thresholds (assuming small fraction of positive cells)
cat(paste0("[",format(Sys.time()),"] "),"automatic theshold determination (outliers)\n")
channels.outliers=channels[sapply(channels,function(channel){"outliers"%in%automatic.thresholding.method[[channel]]})]
for(channel in channels.outliers)
{
    channel.name=metadata[channel,"name"]
    if(metadata.status[channel,"status"]%in%c("NOT_DONE","FAILED"))
    {
        ##aggressive filtering on sharpness
        idx=which(to.keep&nucleusFeatures.image[["shape"]][,"sharpness"]>5)
        if(length(idx)>100)
        {
            iqr=quantile(x.transfo(data.score[idx,channel]),c(0.25,0.75),na.rm=TRUE)
            f.iqr=2
            metadata.channel.thresholding[channel,"threshold"]=min(x.inv.transfo(iqr[2]+f.iqr*(iqr[2]-iqr[1])), #75-th percentile + f.iqr*interquartile range (transformed data)
                                                                   max(data.score[to.keep,channel]))#to avoid too high thresholds
            metadata.status[channel,"status"]="WARNING"
            cat(paste0("[",format(Sys.time()),"] ")," ",channel.name,": ",signif(100*sum(data.score[idx,channel]>metadata.channel.thresholding[channel,"threshold"])/length(idx),2),"% positive cells (cells with sharpness>5)\n",sep="")
        }
    }
}


##plot
##aggressive filtering on sharpness
for(channel in channels)
{
    channel.name=metadata[channel,"name"]
    filename=paste0(outputdir,"/automatic_channel_thresholding_",tolower(channel.name),".pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,8,6)
    ##aggressive filtering on sharpness
    idx=which(to.keep&nucleusFeatures.image[["shape"]][,"sharpness"]>5)
    bw=max(bw.min,max(x.transfo(data.score[idx,channel]))/20)
    if(length(idx)==0)
    {
        plot(0,0,type="n",xlab="",ylab="",xaxt="n",yaxt="n")
    }
    if(length(idx)>0)
    {
        hist(x.transfo(data.score[idx,channel]),breaks=50,freq=FALSE,xlab=paste0(channel.name," score"),main=paste0("Distribution of ",channel.name," score\nwith ",channel.name,ifelse(metadata.status[channel,"status"]!="FAILED"," per tile threshold (grey lines) and","")," final threshold (red line): ",signif(metadata.channel.thresholding[channel,"threshold"],4)," (",metadata.status[channel,"status"],")"),cex.main=0.8,cex.axis=0.8,border="grey60",col="grey95",xaxt="n")
        tmp=density(x.transfo(data.score[idx,channel]),bw=bw,n=1024)
        x=tmp$x
        y=tmp$y
        lines(x,y,col="blue")
        ch=channel
        abline(v=x.transfo(thresholds.tmp[channel==ch,threshold]),col=rgb(0,0,0,0.1),lw=1)
        abline(v=x.transfo(metadata.channel.thresholding[channel,"threshold"]),col="red",lw=2)
        ########### axis (for transfo=sqrt(x)#####
        xmin=min(data.score[idx,channel])
        xmax=max(data.score[idx,channel])
        if(xmax-xmin>1e-6)
        {
            l=ceiling(log10(xmax))
            ##major
            xlab1=(floor(xmin/10**(l-1)):ceiling(xmax/10**(l-1)))*10**(l-1)
            ##minor1
            xlab2=(xlab1[-1]+xlab1[-length(xlab1)])/2
            ##minor2
            xlab3=((min(xlab1)/10**(l-2)):(max(xlab1)/10**(l-2)))*10**(l-2)
            xlab3=xlab3[!xlab3%in%c(xlab1,xlab2)]
            ##minor2
            xlab4=((xlab1[1]/10**(l-3)):(10**(l-2)/10**(l-3)))*10**(l-3)
            xlab4=xlab4[!xlab4%in%c(xlab1,xlab2,xlab3)]
            axis(1,at=x.transfo(xlab1),labels=xlab1,tcl=-0.6,cex.axis=0.8)
            xlab=FALSE;
            if(length(xlab1)+length(xlab2)<15)xlab=xlab2
            axis(1,at=x.transfo(xlab2),labels=xlab,tcl=-0.5,cex.axis=0.8)
            xlab=FALSE;
            if(length(xlab1)+length(xlab2)+length(xlab3)<15)xlab=xlab3
            axis(1,at=x.transfo(xlab3),labels=xlab,tcl=-0.3,cex.axis=0.8)
            xlab=FALSE;
            if(length(xlab1)+length(xlab2)+length(xlab3)+length(xlab4)<15)xlab=xlab4
            axis(1,at=x.transfo(xlab4),labels=xlab,tcl=-0.1,cex.axis=0.8)
        }
    }
    dev.off()
}


############################################
## save
############################################
##status
cat(paste0("[",format(Sys.time()),"] "),ck.channel.name,"threshold=",metadata.channel.thresholding[input.ck,"threshold"],"\n")
filename=paste0(outputdir,"/automatic_channel_thresholding_status.txt")
write.table(metadata.status,file=filename,sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)


##thresholds
filename=paste0(outputdir,"/automatic_channel_thresholding.txt")
cat(paste0("[",format(Sys.time()),"] "),"Saving results in",filename,"\n")
write.table(metadata.channel.thresholding[,colnames(metadata.channel.thresholding)!="automatic.thresholding.method"],file=filename,sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)


cat(paste0("[",format(Sys.time()),"] "),"Done\n")
