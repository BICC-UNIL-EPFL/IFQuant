#!/usr/bin/env Rscript

## Copyright (C) 2022 Julien Dorier and UNIL (University of Lausanne).
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <https://www.gnu.org/licenses/>.

##########################################
#parse command line options
##########################################
          
args=commandArgs(trailingOnly = TRUE)

library(optparse)

usage="
  %prog [options] merge_cells_RData tissue_segmentation_RData"

description="
Positional arguments:
\tmerge_cells_RData
\t\tRData file generated by merge_cells.R.
\ttissue_segmentation_RData
\t\tRData file generated by tissue_segmentation.R."

epilogue=""

#default=NA => mandatory, default=NULL => optional.
option_list=list(
    make_option(c("--tmpdir"), type="character", default=NULL,metavar="DIRNAME",
                help="Directory to save temporary images [Default R tempdir()].
\t\tConsider using /dev/shm/."),
    make_option(c("--nprocesses"), type="integer", default=1,metavar="N",
                help="Max number of threads to use (only for data.table) [default %default]."),
    make_option(c("--thresholds"), type="character", default=NULL,metavar="FILENAME",
                help="File with channel thresholding information.
\t\tTab separated file with header in the first row and at least 4 columns:
\t\t * channel: channel number (0, 1, 2, ...).
\t\t * name: channel name (DAPI, CD15,... must correspond to metadata).
\t\t * score.type: score type
\t\t    should have the form <summary_statistic>.<region> with
\t\t    <summary_statistic>=mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050
\t\t     where q<n> is the n-th percentile and circular.q<n> is the n-th percentile of max in all directions.
\t\t    <region>=nucleus, extended.nucleus or around.nucleus
\t\t    e.g. mean.nucleus, median.extended.nucleus, q001.nucleus, q095.around.nucleus, circular.q010.around.nucleus
\t\t * threshold: numeric threshold. A cell is \"positive\" for a channel if its score is above threshold.
\t\tIf not specified: use thresholds saved in tissue_segmentation_RData."),
    make_option(c("--excluded-regions"), type="character", default=NULL,metavar="FILENAME",
                help="File with excluded regions (closed polygons).
\t\tComma separated format with header in the first row and 3 columns: id, x and y.
\t\tThis file can contain multiple polygons, each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point.
\t\tAll cells with center inside an excluded region will be ignored."),
    make_option(c("--ROI"), type="character", default=NULL,metavar="FILENAME",
                help="File with regions of interest (closed polygons).
\t\tComma separated format with header in the first row, 3 mandatory columns and 1 optional column: id, x, y and label (optional).
\t\tThis file can contain multiple polygons (ROI), each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point."),
    make_option(c("--min-density-all"), type="numeric", default=0,metavar="D",
                help="Minimum local cell density (number of cells/mm^2) [default %default].
\t\tCells with selected phenotype and local density below D will be ignored for clustering and patch boundary detection."),
    make_option(c("--min-density-selected"), type="numeric", default=0,metavar="D",
                help="Minimum local density of cells with selected phenotype (number cells with selected phenotype/mm^2) [default %default].
\t\tCells with selected phenotype and local density below D will be ignored for clustering and patch boundary detection.
\t\tNote: --min-density-all uses the local cell density (using all cells),
\t\twhile --min-density-selected use the local density of cells with selected phenotype only (ignore other cells when evaluating density)."),
    make_option(c("--min-patch-size-all"), type="numeric", default=0,metavar="N",
                help="Mimimum patch size (number of cells) [default %default].
\t\tUsed to filter final patches.
\t\tNote that patch of size<3 are always ignored."),
    make_option(c("--min-patch-size-selected"), type="numeric", default=40,metavar="N",
                help="Mimimum patch size (number of cells with selected phenotype) [default %default].
\t\tUsed to filter clusters and final patches.
\t\tNote that patch of size<3 are always ignored.
\t\tNote: --min-patch-size-all consider all cells
\t\twhile --min-patch-size-selected consider only cells with selected phenotype."),
    make_option(c("--min-patch-density-all"), type="numeric", default=0,metavar="D",
                help="Mimimum patch average density (number of cells/mm^2) [default %default].
\t\tEstimated as number of cells with selected phenotype in the patch divided by area of the patch.
\t\tUsed to filter final patches."),
    make_option(c("--min-patch-density-selected"), type="numeric", default=0,metavar="D",
                help="Minimum patch average density of cells with selected phenotype (number of cells with selected phenotype/mm^2) [default %default].
\t\tEstimated as number of cells with selected phenotype in the patch divided by area of the patch.
\t\tUsed to filter clusters and final patches.
\t\tNote: --min-patch-density-all consider all cells
\t\twhile --min-patch-density-selected consider only cells with selected phenotype."),
    make_option(c("--min-patch-area"), type="numeric", default=0,metavar="A",
                help="Mimimum patch area (mm^2) [default %default].
\t\tUsed to filter final patches."),
    make_option(c("--clustering-method"), type="character", default="none",metavar="M",
                help="Initial clustering of the cells with phenotype --phenotype  [default %default].
\t\tPossible values:
\t\t * louvain:   Consider the graph G obtained by the delaunay triangulation on all cells.
\t\t              Use Louvain clustering (igraph::cluster_louvain()) on the subgraph of G obtained
\t\t              by keeping only cells with phenotype specified by --phenotype.    
\t\t * connected: Consider the graph G obtained by the delaunay triangulation on all cells.
\t\t              Use connected components (igraph::cluster_louvain()) in the subgraph of G obtained
\t\t              by keeping only cells with phenotype specified by --phenotype.
\t\t * none:      No clustering (i.e. a unique cluster with all cells with phenotype specified by --phenotype)."),
    make_option(c("--boundary-method"), type="character", default="alphashape",metavar="M",
                help="Method used to find the boundary around each cluster [default %default].
\t\tPossible values:
\t\t * alphashape: Use alpha shape (clusters can be split into multiple patches).
\t\t * convexhull: Use convex hull."),
    make_option(c("--boundary-param"), type="numeric", default=20,metavar="P",
                help="Parameters for the boundary detection method [default %default].
\t\tWith --boundary-method=alphashape the parameter is the alpha radius (in micron).
\t\tWith --boundary-metod=convexhull it is ignored."),
    make_option(c("--output-selected-mask"), type="character", default=NULL,metavar="DIRNAME",
                help="Output image mask showing cells with selected phenotype
\t\t(after filtering with --min-density-all and --min-density-selected)
\t\tin white over black background (generate tiles in directory DIRNAME)."),
    make_option(c("--output-patch-mask"), type="character", default=NULL,metavar="DIRNAME",
                help="Output image mask showing patches in white over black background
\t\t(generate tiles in directory DIRNAME)."),
    make_option(c("--output"), type="character", default=NA,metavar="DIRNAME",
                help="Output directory [mandatory]."),
    make_option(c("--phenotype"), type="character", default=NA,metavar="PHENOTYPE",
                help="Select cells with this phenotype and find patches enclosing these cells [mandatory].
\t\tPHENOTYPE must be a comma separated list of marker names followed by + or -.
\t\tE.g. --phenotype=CD3+,CD4- will select all cells with CD3 score above threshold
\t\tand CD4 score below threshold (ignoring other markers).
\t\tMarker names will be matched to column \"name\" in the panel metadata.")
)


opt=parse_args(OptionParser(option_list=option_list,
                            usage=usage,
                            description=description,
                            epilogue=epilogue
                            ),positional_arguments=2,args=args)

##check all options are set, and print them
for(o in option_list)
{
    n=slot(o,"dest")
    f=c(slot(o,"short_flag"),slot(o,"long_flag"))
    f=paste(f[!is.na(f)],sep=",")
    if(!is.null(opt$options[[n]])) ##Default NULL => optional.
    {
        if(is.na(opt$options[[n]])) ##Default NA => mandatory
            stop("option ",f," is mandatory")
        ##check type
        if(typeof(opt$options[[n]])!=slot(o,"type"))
            stop("option ",f," must be ",slot(o,"type"))
        ##print
        if(slot(o,"action")!="store_true")
            cat(slot(o,"long_flag"),"=",opt$options[[n]],"\n",sep="")
        if(slot(o,"action")=="store_true"&&opt$options[[n]]==TRUE)
            cat(slot(o,"long_flag"),"\n",sep="")
    }
}
cat("positional arguments: ",paste(opt$args,collapse=" "),"\n",sep="")

tmpdir=opt$options[["tmpdir"]]
nprocesses=opt$options[["nprocesses"]]
input.thresholding=opt$options[["thresholds"]]
input.excluded.regions=opt$options[["excluded-regions"]]
input.ROI=opt$options[["ROI"]]
minimum.local.density.all.cells.mm2=opt$options[["min-density-all"]]
minimum.local.density.selected.phenotype.mm2=opt$options[["min-density-selected"]]
minimum.patch.size.all.cells=opt$options[["min-patch-size-all"]]
minimum.patch.size.selected.phenotype=opt$options[["min-patch-size-selected"]]
minimum.patch.density.all.cells.mm2=opt$options[["min-patch-density-all"]]
minimum.patch.density.selected.phenotype.mm2=opt$options[["min-patch-density-selected"]]
minimum.patch.area.mm2=opt$options[["min-patch-area"]]
clustering.method=opt$options[["clustering-method"]]
boundary.method=opt$options[["boundary-method"]]
boundary.param=opt$options[["boundary-param"]]
outputdir.selected.mask=opt$options[["output-selected-mask"]]
outputdir.patch.mask=opt$options[["output-patch-mask"]]
outputdir=opt$options[["output"]]
selected.phenotype=opt$options[["phenotype"]]


##check
if(is.null(tmpdir))
{
    tmpdir=tempdir()
    cat("using tmpdir=",tmpdir,"\n",sep="")
}
if(!(is.finite(nprocesses)&nprocesses>0))
{
    stop("--nprocesses must be a positive integer")
}

##positional arguments
input_merge_cells.RData=opt$args[1]
input_tissue_segmentation.RData=opt$args[2]




dir.create(outputdir,showWarnings=FALSE,recursive=TRUE)
library(parallel)
library(data.table)
library(sp) #point.in.polygon
library(igraph)
library(RANN)
options(scipen=13)

setDTthreads(nprocesses)

##temporary directory
tmpdir=paste0(tempfile(pattern="tmp",tmpdir=tmpdir),"/")
dir.create(tmpdir,showWarnings=FALSE,recursive=TRUE)

##temporary directory cleaning
clean=function(){
    cat(paste0("[",format(Sys.time()),"] "),"removing",tmpdir,"\n")
    unlink(tmpdir, recursive=TRUE)
}
##erase temporary directory on error    
if(!interactive())
    options(error=function(){clean();quit(status = 1)})

##replace all non-allowed characters by "_"
##forbidden: a pattern (used in gsub)
##replace_by: characted to use for replacement
str_sanitize_path=function(x,forbidden="[^a-zA-Z0-9_-]",replace_by="_"){
    x=gsub(paste0(forbidden,"+"),replace_by,x)
    return(x)
}

############################################
##load
############################################

cat(paste0("[",format(Sys.time()),"] "),"loading",input_merge_cells.RData,"\n")
load(input_merge_cells.RData)
image.info.tmp=image.info
metadata.tmp=metadata

cat(paste0("[",format(Sys.time()),"] "),"loading",input_tissue_segmentation.RData,"\n")
load(input_tissue_segmentation.RData)

##simple check
if(!identical(image.info.tmp,image.info))
{
    stop("inconsistent image.info in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}
if(!identical(metadata.tmp,metadata))
{
    stop("inconsistent metadata in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}

if(!is.null(input.thresholding))
{
    cat(paste0("[",format(Sys.time()),"] "),"loading",input.thresholding,"\n")
    metadata.channel.thresholding.tmp=read.table(input.thresholding,header=TRUE,stringsAsFactors=FALSE,sep="\t")
    metadata.channel.thresholding.tmp=metadata.channel.thresholding.tmp[order(metadata.channel.thresholding.tmp$channel),]
    rownames(metadata.channel.thresholding.tmp)=paste0("channel_",metadata.channel.thresholding.tmp$channel)
    ##check
    channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
    if(!all(metadata.channel.thresholding[channels,"channel"]==metadata.channel.thresholding.tmp[channels,"channel"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(metadata.channel.thresholding[channels,"name"]==metadata.channel.thresholding.tmp[channels,"name"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(c("score.type","threshold")%in%colnames(metadata.channel.thresholding.tmp)))
    {
        stop("Invalid",input.thresholding)
    }
    ##replace
    metadata.channel.thresholding=metadata.channel.thresholding.tmp
}

########################################
#convert densities and area
########################################
## convert densities from cell/mm^2 to  cell/pixel^2 (convert.slide.to.image.area() is not used as the result is rounded to nearest integer)
pixel2.to.micron2=convert.image.to.slide.area(1,image.info)
minimum.local.density.all.cells=minimum.local.density.all.cells.mm2*pixel2.to.micron2/1e6 #in cells/pixel^2
minimum.local.density.selected.phenotype=minimum.local.density.selected.phenotype.mm2*pixel2.to.micron2/1e6 #in cells/pixel^2

minimum.patch.density.all.cells=minimum.patch.density.all.cells.mm2*pixel2.to.micron2/1e6 #in cells/pixel^2
minimum.patch.density.selected.phenotype=minimum.patch.density.selected.phenotype.mm2*pixel2.to.micron2/1e6 #in cells/pixel^2

## convert area from mm^2 to  pixel^2
minimum.patch.area=minimum.patch.area.mm2*1e6/pixel2.to.micron2 #in cells/pixel^2

########################################
#selected phenotypes
########################################
tmp=rbindlist(lapply(strsplit(selected.phenotype,",")[[1]],function(x){
    name=gsub("(.*)(.)","\\1",x)
    sign=gsub("(.*)(.)","\\2",x)
    channel=rownames(metadata)[metadata$name==name]
    data.table(name,sign,channel)
}))


##check
if(!all(tmp$sign%in%c("+","-")))
{
    stop("Invalid --phenotype=",selected.phenotype)
}
if(!all(tmp$channel%in%rownames(metadata)))
{
    tmp[!tmp$channel%in%rownames(metadata),name]
    stop("Invalid --phenotype=",selected.phenotype,". Marker(s) ",paste( tmp[!tmp$channel%in%rownames(metadata),name],collapse=", ")," not found in metadata")
}
if(any(tmp$channel%in%rownames(metadata)[metadata$channel%in%c(channel.dapi,channel.autofluorescence)]))
{
    stop("Invalid --phenotype=",selected.phenotype,". Marker(s) ",paste( tmp[tmp$channel%in%rownames(metadata)[metadata$channel%in%c(channel.dapi,channel.autofluorescence)],name],collapse=", ")," not found in metadata")
}

input.positive.markers=tmp[sign=="+",channel]
input.negative.markers=tmp[sign=="-",channel]


cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
selected.phenotypes=as.data.frame(matrix("*",ncol=length(cols),nrow=1,dimnames=list(NULL,cols)))
selected.phenotypes[,input.positive.markers]="+"
selected.phenotypes[,input.negative.markers]="-"
##duplicate "*" into "-" and "+"
for(col in cols)
{
    tmp=selected.phenotypes[selected.phenotypes[,col]=="*",]
    if(nrow(tmp)>0)
    {
        selected.phenotypes[selected.phenotypes[,col]=="*",col]="-"
        tmp[,col]="+"
        selected.phenotypes=rbind(selected.phenotypes,tmp)
    }
}
##create label
for(col in cols)
{
    channel.name=metadata[col,"name"]
    selected.phenotypes$label=paste0(selected.phenotypes$label,ifelse(selected.phenotypes[,col]%in%c("-","+"),paste0(channel.name,selected.phenotypes[,col]),""))
}



############################################
##load ROI
############################################
regions.of.interest=data.table(id=integer(0),label=character(0))
if(!is.null(input.ROI))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.ROI,"\n")
    regions.of.interest=fread(input.ROI)
    if(!"label"%in%colnames(regions.of.interest))
    {
        tmp=paste0("ROI ",seq_along(sort(unique(regions.of.interest$id))))
        names(tmp)=as.character(sort(unique(regions.of.interest$id)))        
        regions.of.interest[,label:=tmp[as.character(id)]]
    }
}
regions.of.interest.labels=sort(unique(regions.of.interest[,label]))
regions.of.interest.ids=lapply(regions.of.interest.labels,function(l){regions.of.interest[label==l,unique(id)]})
names(regions.of.interest.ids)=regions.of.interest.labels

############################################
##load excluded region
############################################

excluded.regions=data.table(id=integer(0))
if(!is.null(input.excluded.regions))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.excluded.regions,"\n")
    excluded.regions=fread(input.excluded.regions)
}


############################################
## Evaluate score
############################################

cat(paste0("[",format(Sys.time()),"] "),"evaluating score\n")
if(is.null(nucleusFeatures.image))
{
    cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
    coln=paste0(cols,".above.threshold")
    data.score.above.threshold=matrix(logical(0),ncol=length(coln),nrow=0,dimnames=list(NULL,coln))
    data.score.above.threshold=cbind(cell.ID=numeric(0),nucleus.x=numeric(0),nucleus.y=numeric(0),data.score.above.threshold)
}
if(!is.null(nucleusFeatures.image))
{
    data.score.above.threshold=nucleusFeatures.image[["shape"]][,c("cell.ID","nucleus.x","nucleus.y"),drop=FALSE]
    for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
    {
        score.type=metadata.channel.thresholding[f,"score.type"]
        threshold=metadata.channel.thresholding[f,"threshold"]
        ##split score.type into summary statistic and region
        score.type.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",score.type)
        score.type.statistic=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",score.type)
        ##check
        if(!score.type.region%in%c("nucleus","extended.nucleus","around.nucleus"))
            stop("Invalid score type",score.type,". Accepted regions: nucleus, extended.nucleus or around.nucleus")
        if(!score.type.statistic%in%c("mean","median","q001","q005","q025","q075","q095","q099","circular.q005","circular.q010","circular.q025","circular.q050"))
            stop("Invalid score type ",score.type,". Accepted summary statistics: mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050")
        if(score.type.statistic=="median")score.type.statistic="q050"

        if(score.type.region=="nucleus")
        {
            data.score.above.threshold=cbind(data.score.above.threshold,nucleusFeatures.image[[f]][,score.type.statistic]>threshold)        
        }
        if(score.type.region=="extended.nucleus")
        {
            data.score.above.threshold=cbind(data.score.above.threshold,extendedNucleusFeatures.image[[f]][,score.type.statistic]>threshold)
        }
        if(score.type.region=="around.nucleus")
        {
            data.score.above.threshold=cbind(data.score.above.threshold,aroundNucleusFeatures.image[[f]][,score.type.statistic]>threshold)
        }
    }
    cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
    colnames(data.score.above.threshold)=c("cell.ID","nucleus.x","nucleus.y",paste0(cols,".above.threshold"))
}


rm(extendedNucleusFeatures.image)
rm(aroundNucleusFeatures.image)
rm(nucleusFeatures.image)
gc()

set.seed(12734)

############################################
## merge & clean
############################################

setkey(voronoi.cells.summary,cell.ID)
##check cell.ID corresponds to row index
if(!voronoi.cells.summary[,all(cell.ID==.I)])
  stop("problem with cell.ID")
data.all=data.table(data.score.above.threshold,voronoi.cells.summary[data.score.above.threshold[,"cell.ID"],.(tissue.type,area)])
setkey(data.all,cell.ID)
##check cell.ID corresponds to row index
if(!data.all[,all(cell.ID==.I)])
  stop("problem with cell.ID")

rm(data.score.above.threshold)
gc()
############################################
## add phenotypes
############################################

### create phenotype.raw (concatenate <channel>+ or <channel>-)
data.all[,phenotype.raw:=""]
for(col in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    channel.name=metadata[col,"name"]
    data.all$phenotype.raw=paste0(data.all$phenotype.raw,channel.name,ifelse(unlist(data.all[,paste0(col,".above.threshold"),with=FALSE]),"+","-"))
}

##remove useless columns
cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
data.all[,paste0(cols,".above.threshold"):=NULL]

############################################
## flag cells to filter out (excluded regions)
############################################

data.all[,excluded:=FALSE]
if(!is.null(input.excluded.regions))
{
    ##exclude points
    for(i in excluded.regions[,unique(id)])
        data.all$excluded=data.all$excluded|(point.in.polygon(data.all$nucleus.x,data.all$nucleus.y,excluded.regions[id==i,x],excluded.regions[id==i,y])!=0)

}


############################################
## flag cells with selected phenotype
############################################

data.all[,selected.phenotype:=phenotype.raw%in%selected.phenotypes$label]

data.all[,selected:=selected.phenotype&!excluded]

############################################
## local density of cells
############################################
if(minimum.local.density.all.cells>0)
{
    if(nrow(data.all[excluded==FALSE])>0)
    {
        ##estimate local density using k nearest neighbor (consider all non-excluded cells)
        k=5
        k=min(k,nrow(data.all[excluded==FALSE])) ##to avoid crash with few cells
        tmp=nn2(data.all[excluded==FALSE,.(nucleus.x,nucleus.y)],k=k)       
        r=tmp$nn.dists[,k] #distance to k-th nearest neighbor
        n=rowSums(tmp$nn.dists<r) #number of neighbors strictly below r
        rm(tmp)
        ##Unselect cells with density below threshold:
        ##density estimated as n/(pi*r^2), i.e. number of cells within a disk of radius r (excluding cells on the contour of the disk)
        data.all[excluded==FALSE,selected.tmp:=(n/(pi*r^2)>=minimum.local.density.all.cells)]
        data.all[selected==TRUE,selected:=selected.tmp]
        data.all[,selected.tmp:=NULL]
        rm(r)
        rm(n)
    }
}

############################################
## local density of cells with selected phenotype
############################################
if(minimum.local.density.selected.phenotype>0)
{
    if(nrow(data.all[selected.phenotype==TRUE&excluded==FALSE])>0)
    {
        ##estimate local density using k nearest neighbor (consider only non-excluded cells with selected phenotype)
        k=5
        k=min(k,nrow(data.all[selected.phenotype==TRUE&excluded==FALSE])) ##to avoid crash with few cells
        tmp=nn2(data.all[selected.phenotype==TRUE&excluded==FALSE,.(nucleus.x,nucleus.y)],k=k)       
        r=tmp$nn.dists[,k] #distance to k-th nearest neighbor
        n=rowSums(tmp$nn.dists<r) #number of neighbors strictly below r
        rm(tmp)
        ##Unselect cells with density below threshold:
        ##density estimated as n/(pi*r^2), i.e. number of cells within a disk of radius r (excluding cells on the contour of the disk)
        data.all[selected.phenotype==TRUE&excluded==FALSE,selected.tmp:=(n/(pi*r^2)>=minimum.local.density.selected.phenotype)]
        data.all[selected==TRUE,selected:=selected.tmp]
        data.all[,selected.tmp:=NULL]
        rm(r)
        rm(n)
    }
}


############################################
## Clustering (delaunay triangulation/voronoi tesselation)
############################################

data.all[,cluster.ID:=1]
if(clustering.method%in%c("louvain","connected"))
{
    cat(paste0("[",format(Sys.time()),"] "),"creating delaunay graph for initial clustering\n")
    ##keep only subgraph of selected cells (i.e. not in excluded regions and with selected.phenotype) and valid edges  (i.e. with length<=max.connectivity.distance.pixel)
    e=delaunay.edges[valid==TRUE&cell.ID1%in%data.all[selected==TRUE,cell.ID]&cell.ID2%in%data.all[selected==TRUE,cell.ID]]
    v=data.all[selected==TRUE,.(cell.ID=cell.ID)]
    g=graph_from_data_frame(e, directed = FALSE, vertices = v)

    if(clustering.method=="connected")
    {
        cat(paste0("[",format(Sys.time()),"] "),"connected components clustering\n")
        ## evaluate connected components (i.e. groups of connected cells with same selected.phenotype status)
        clusters=components(g)
    }
    if(clustering.method=="louvain")
    {
        cat(paste0("[",format(Sys.time()),"] "),"louvain clustering\n")
        ##Louvain communities
        clusters=cluster_louvain(g)
    }

    ##update cluster.ID to data.all
    data.all[,cluster.ID:=as.numeric(NA)]
    data.all[data.table(cell.ID=as.numeric(V(g)$name)),cluster.ID:=as.numeric(membership(clusters))]

    ##filter clusters based on sizes
    tmp=data.all[,.(size=.N),by=.(cluster.ID)]
    tmp[size>=minimum.patch.size.selected.phenotype,new.cluster.ID:=cluster.ID]
    data.all[,cluster.ID:=tmp[data.all,.(cluster.ID=new.cluster.ID),on=.(cluster.ID)]]

}



############################################
##function alpha shape
############################################
##Note: package alphahull crashes on several examples and thus cannot be used here

##x,y: numeric vectors of x and y coordinates.
##group: optional. should have same size as x and y. create alpha shape for each group separately.
##alpha: radius of the alpha ball.
##keep.points: logical, indicating whether isolated points should be returned (TRUE) or ignored (FALSE)
##only.exterior: logical, indicating whether only external contours should be returned (TRUE), or if holes contours should also be returned (FALSE).
##expand: numeric value by which the resulting boundaries should be moved toward the exterior (should be a small number, there is no crossing checks). Note: only for polygons with more than 2 points
alpha.shape=function(x,y,group=NULL,alpha=1,keep.points=TRUE,only.exterior=FALSE,expand=1){

    if(!is.null(group))
    {
        delaunay.points=data.table(x,y,group.ID=group)
    }
    if(is.null(group))
    {
        delaunay.points=data.table(x,y,group.ID=1)
    }
    ##add point ID
    delaunay.points[,p.ID:=1:.N]

    ## ############################
    ## delaunay triangulation
    ## ############################
    delaunay.triangulation=function(p.ID,x,y){
        if(length(x)<3)
        {
            return(data.table(p.ID1=integer(0),p.ID2=integer(0),p.ID3=integer(0)))
        }
        if(length(x)==3)
        {
            return(data.table(p.ID1=p.ID[1],p.ID2=p.ID[2],p.ID3=p.ID[3]))
        }        
        tmp=geometry::delaunayn(cbind(x,y))
        data.table(p.ID1=p.ID[tmp[,1]],p.ID2=p.ID[tmp[,2]],p.ID3=p.ID[tmp[,3]])
    }
    delaunay.triangles=delaunay.points[,delaunay.triangulation(p.ID,x,y),by=.(group.ID)]
    delaunay.triangles[,tri.ID:=1:.N]
    ##add circumcenters (https://www.ics.uci.edu/~eppstein/junkyard/circumcenter.html)
    delaunay.triangles[,x1:=delaunay.points[delaunay.triangles,"x",on=c("p.ID"="p.ID1")]]
    delaunay.triangles[,y1:=delaunay.points[delaunay.triangles,"y",on=c("p.ID"="p.ID1")]]
    delaunay.triangles[,x2:=delaunay.points[delaunay.triangles,"x",on=c("p.ID"="p.ID2")]]
    delaunay.triangles[,y2:=delaunay.points[delaunay.triangles,"y",on=c("p.ID"="p.ID2")]]
    delaunay.triangles[,x3:=delaunay.points[delaunay.triangles,"x",on=c("p.ID"="p.ID3")]]
    delaunay.triangles[,y3:=delaunay.points[delaunay.triangles,"y",on=c("p.ID"="p.ID3")]]
    delaunay.triangles[,xba:=x2-x1]
    delaunay.triangles[,yba:=y2-y1]
    delaunay.triangles[,xca:=x3-x1]
    delaunay.triangles[,yca:=y3-y1]
    delaunay.triangles[,ba:=xba * xba + yba * yba]
    delaunay.triangles[,ca:=xca * xca + yca * yca]
    delaunay.triangles[,d:=0.5 / (xba * yca - yba * xca)]
    delaunay.triangles[,circumcircle.x:=(yca * ba - yba * ca) * d]
    delaunay.triangles[,circumcircle.y:=(xba * ca - xca * ba) * d]
    delaunay.triangles[,circumcircle.r2:=(xba-circumcircle.x)^2+(yba-circumcircle.y)^2]
    delaunay.triangles[,circumcircle.x:=x1+circumcircle.x]
    delaunay.triangles[,circumcircle.y:=y1+circumcircle.y]
    delaunay.triangles[,orientation:=xba*yca-yba*xca]
    ##reorder points counter clockwise
    delaunay.triangles[orientation<0,c("p.ID2","p.ID3"):=.(p.ID3,p.ID2)]
    ##flag triangles as:
    ## in: inside the alpha shape i.e. circumcircle radius<=alpha  (and not exterior)
    ## out: not inside the alpha shape i.e. circumcircle radius>alpha  (and not exterior). Could be a hole
    delaunay.triangles[,type:="out"]
    delaunay.triangles[circumcircle.r2<=alpha^2,type:="in"]
    ##remove columns
    delaunay.triangles[,x1:=NULL]
    delaunay.triangles[,y1:=NULL]
    delaunay.triangles[,x2:=NULL]
    delaunay.triangles[,y2:=NULL]
    delaunay.triangles[,x3:=NULL]
    delaunay.triangles[,y3:=NULL]
    delaunay.triangles[,xba:=NULL]
    delaunay.triangles[,yba:=NULL]
    delaunay.triangles[,xca:=NULL]
    delaunay.triangles[,yca:=NULL]
    delaunay.triangles[,ba:=NULL]
    delaunay.triangles[,ca:=NULL]
    delaunay.triangles[,d:=NULL]
    delaunay.triangles[,orientation:=NULL]    

    setkey(delaunay.triangles,tri.ID)

    ## ############################
    ## delaunay edges
    ## ############################
    cat(paste0("[",format(Sys.time()),"] "),"extracting delaunay edges\n")
    delaunay.edges=rbind(
        unique(delaunay.triangles[,.(p.ID1=pmin(p.ID1,p.ID2),p.ID2=pmax(p.ID1,p.ID2),tri.ID)]),
        unique(delaunay.triangles[,.(p.ID1=pmin(p.ID2,p.ID3),p.ID2=pmax(p.ID2,p.ID3),tri.ID)]),
        unique(delaunay.triangles[,.(p.ID1=pmin(p.ID3,p.ID1),p.ID2=pmax(p.ID3,p.ID1),tri.ID)]))[,.(tri.ID1=min(tri.ID),tri.ID2=max(tri.ID)),by=.(p.ID1,p.ID2)]

    ##add triangle type
    setkey(delaunay.edges,tri.ID1)
    delaunay.edges[,tri.type1:=delaunay.triangles[delaunay.edges,type]]
    setkey(delaunay.edges,tri.ID2)
    delaunay.edges[,tri.type2:=delaunay.triangles[delaunay.edges,type]]
    ##Note: delaunay.edges with same tri.ID1==tri.ID2 correspond to exterior edges:
    delaunay.edges[tri.ID1==tri.ID2,tri.type2:="ext"]
    delaunay.edges[tri.ID1==tri.ID2,tri.ID2:=NA]
    
    ## ############################
    ## find regions outside of the alpha shape (exterior and holes)
    ## ############################

    ## build graph with
    ##  vertex: triangle with type "out" or "ext" (not "in"). A unique vertex with name "ext" will summarize exterior)
    ##  edges: delaunay edges connecting "out" or "ext" triangles to "out" or "ext" triangles
    e=delaunay.edges[tri.type1!="in"&tri.type2!="in",.(tri.ID1=ifelse(tri.type1!="ext",tri.ID1,"ext"),tri.ID2=ifelse(tri.type2!="ext",tri.ID2,"ext"))]
    if(nrow(e)>0)
    {
        g=graph_from_data_frame(e, directed = FALSE)
        
        ##find connected components
        cmp=components(g)
        ##find exterior component
        v.ext=V(g)["ext"]
        exterior.region.ID=cmp$membership[v.ext]
        
        ##add a column out.region.ID to all triangle (or NA for "in" triangle)
        delaunay.triangles[,out.region.ID:=as.integer(NA)]
        delaunay.triangles[data.table(tri.ID=as.integer(V(g)[-v.ext]$name)),out.region.ID:=cmp$membership[V(g)[-v.ext]],on=.(tri.ID)]
        rm(cmp)
        rm(g)
    }
    if(nrow(e)==0)
    {
        exterior.region.ID=1
        delaunay.triangles[,out.region.ID:=as.integer(NA)]
    }    
    rm(e)
    
    ##add column out.region.ID to edges
    delaunay.edges[,tri.out.region.ID1:=delaunay.triangles[delaunay.edges,out.region.ID,on=c("tri.ID"="tri.ID1")]]
    delaunay.edges[,tri.out.region.ID2:=delaunay.triangles[delaunay.edges,out.region.ID,on=c("tri.ID"="tri.ID2")]]
    ##set out.region.ID to exterior.region.ID for exterior edges
    delaunay.edges[tri.type2=="ext",tri.out.region.ID2:=exterior.region.ID]
    delaunay.edges[tri.type1=="ext",tri.out.region.ID1:=exterior.region.ID]

    ##flag points a "in" (part of an "in" triangle, including on the border), "out" (not part of "in" triangle and not touching the exterior region), and "ext" (not part of an "in" triangle, and in the exterior region)
    delaunay.points[p.ID%in%delaunay.triangles[type!="in",p.ID1],type:="out"]
    delaunay.points[p.ID%in%delaunay.triangles[type!="in",p.ID2],type:="out"]
    delaunay.points[p.ID%in%delaunay.triangles[type!="in",p.ID3],type:="out"]
    delaunay.points[p.ID%in%delaunay.triangles[out.region.ID==exterior.region.ID,p.ID1],type:="ext"]
    delaunay.points[p.ID%in%delaunay.triangles[out.region.ID==exterior.region.ID,p.ID2],type:="ext"]
    delaunay.points[p.ID%in%delaunay.triangles[out.region.ID==exterior.region.ID,p.ID3],type:="ext"]
    delaunay.points[p.ID%in%delaunay.triangles[type=="in",p.ID1],type:="in"]
    delaunay.points[p.ID%in%delaunay.triangles[type=="in",p.ID2],type:="in"]
    delaunay.points[p.ID%in%delaunay.triangles[type=="in",p.ID3],type:="in"]
    
    ## ############################
    ## find contour of the alpha shape (ordered set of points)
    ## ############################

    ##consider only border edges
    delaunay.edges.border=delaunay.edges[tri.type1=="in"&tri.type2!="in"|tri.type1!="in"&tri.type2=="in",]
    ##keep only external border edges
    ##delaunay.edges.border=delaunay.edges[(tri.type1=="in"&tri.type2!="in"|tri.type1!="in"&tri.type2=="in")&(tri.out.region.ID1==exterior.region.ID|tri.out.region.ID2==exterior.region.ID),]

    ##reorient edges (using "in" triangles"): counter-clockwise for exterior boundaries, clockwise for holes.
    tmp=rbind(delaunay.triangles[type=="in",.(p.ID1=pmin(p.ID1,p.ID2),p.ID2=pmax(p.ID1,p.ID2),p.ID1.ordered=p.ID1,p.ID2.ordered=p.ID2)],
              delaunay.triangles[type=="in",.(p.ID1=pmin(p.ID2,p.ID3),p.ID2=pmax(p.ID2,p.ID3),p.ID1.ordered=p.ID2,p.ID2.ordered=p.ID3)],
              delaunay.triangles[type=="in",.(p.ID1=pmin(p.ID3,p.ID1),p.ID2=pmax(p.ID3,p.ID1),p.ID1.ordered=p.ID3,p.ID2.ordered=p.ID1)])
    setkey(tmp,p.ID1,p.ID2)
    setkey(delaunay.edges.border,p.ID1,p.ID2)
    delaunay.edges.border[,c("p.ID1","p.ID2"):=tmp[delaunay.edges.border,.(p.ID1.ordered,p.ID2.ordered)]]

    
    ## #### Treat points with multiple incoming edges (and multiple outgoing edges)
    ## For point with multiple incoming edges (and outgoing edges), make pairs of consecutive incoming and outgoing edge.
    delaunay.edges.border[,in.pair.ID:=0]
    delaunay.edges.border[,out.pair.ID:=0]
    
    ##find delaunay points with multiple incoming edges (and outgoing edges)
    pIDs=delaunay.edges.border[,.N,by=.(p.ID2)][N>1,p.ID2]
    if(length(pIDs)>0)
    {
        ##list incoming/outgoing edges
        tmp2=rbind(delaunay.edges.border[p.ID1%in%pIDs,.(ID=p.ID1,p.ID1,p.ID2,direction="out")],
                   delaunay.edges.border[p.ID2%in%pIDs,.(ID=p.ID2,p.ID1,p.ID2,direction="in")])
        
        ##add positions
        setkey(delaunay.points,p.ID)
        setkey(tmp2,p.ID1)
        tmp2[,x1:=delaunay.points[tmp2,x]]
        tmp2[,y1:=delaunay.points[tmp2,y]]
        setkey(tmp2,p.ID2)
        tmp2[,x2:=delaunay.points[tmp2,x]]
        tmp2[,y2:=delaunay.points[tmp2,y]]
        ##add angle
        tmp2[direction=="out",angle:=atan2(y2-y1,x2-x1)%%(2*pi)]
        tmp2[direction=="in",angle:=atan2(y1-y2,x1-x2)%%(2*pi)]
        ##find minimum incoming angle and use it as reference
        angle.min=tmp2[direction=="in",.(a0=min(angle)),by=.(ID)]
        tmp2[,angle:=(angle-angle.min[tmp2,a0,on=.(ID)])%%(2*pi)]

        setorder(tmp2,angle)
        tmp2[,pair.ID:=((1:.N)-1)%/%2,by=.(ID)]
        tmp2[,in.pair.ID:=0]
        tmp2[,out.pair.ID:=0]
        tmp2[direction=="in",in.pair.ID:=pair.ID]
        tmp2[direction=="out",out.pair.ID:=pair.ID]
        ##for edges appearing twice (both ends have multiple incoming edges)
        tmp2=tmp2[,.(in.pair.ID=max(in.pair.ID),out.pair.ID=max(out.pair.ID)),by=.(p.ID1,p.ID2)]

        delaunay.edges.border[tmp2[,.(p.ID1,p.ID2)],c("in.pair.ID","out.pair.ID"):=tmp2[,.(in.pair.ID,out.pair.ID)],on=.(p.ID1,p.ID2)]#,in.pair.ID,out.pair.ID)]
    }
    ##create a directed graph with delaunay edges (only border edges). Vertice correspond to delaunay points (split if multiple pair.ID)
    e=unique(rbind(delaunay.edges.border[tri.type1!="in",.(paste(p.ID1,tri.out.region.ID1,out.pair.ID),paste(p.ID2,tri.out.region.ID1,in.pair.ID))],
                   delaunay.edges.border[tri.type2!="in",.(paste(p.ID1,tri.out.region.ID2,out.pair.ID),paste(p.ID2,tri.out.region.ID2,in.pair.ID))]))
    v=unique(rbind(delaunay.edges.border[tri.type1!="in",.(p.ID=p.ID1,out.region.ID=tri.out.region.ID1,pair.ID=out.pair.ID)],
                   delaunay.edges.border[tri.type2!="in",.(p.ID=p.ID1,out.region.ID=tri.out.region.ID2,pair.ID=out.pair.ID)],
                   delaunay.edges.border[tri.type1!="in",.(p.ID=p.ID2,out.region.ID=tri.out.region.ID1,pair.ID=in.pair.ID)],
                   delaunay.edges.border[tri.type2!="in",.(p.ID=p.ID2,out.region.ID=tri.out.region.ID2,pair.ID=in.pair.ID)]))[,.(name=paste(p.ID,out.region.ID,pair.ID),p.ID,out.region.ID)]
    if(nrow(v)>0)
    {
        g=graph_from_data_frame(e, directed = TRUE, vertices = v)
        
        ##this graph consists in a set of simple loops. (all vertices will multipe incoming edges were split). A simple depth first search is sufficient to find consecutive points on the border.
        cmp=components(g)
        dfs.order=dfs(g,V(g)[1],neimode="out")
        vertex_attr(g,"dfs.order",dfs.order$order)=1:gorder(g)
        vertex_attr(g,"component")=cmp$membership
        
        boundaries=data.table(p.ID=V(g)$p.ID,contour.ID=V(g)$component,order=V(g)$dfs.order,is.exterior=(V(g)$out.region.ID==exterior.region.ID))[order(contour.ID,order)]
        rm(cmp)
        rm(dfs.order)
        rm(g)
    }
    if(nrow(v)==0)
    {
        boundaries=data.table(p.ID=integer(0),contour.ID=numeric(0),order=numeric(0),is.exterior=logical(0))[order(contour.ID,order)]
    }
    rm(e)
    rm(v)

    ##add type
    boundaries[,type:="exterior"]
    boundaries[is.exterior==FALSE,type:="hole"]
    
    ##add missing points (isolated points in the exterior or inside holes)
    if(keep.points)
    {
        contour.ID.start=boundaries[,max(contour.ID)]
        if(!is.finite(contour.ID.start))contour.ID.start=0
        order.start=boundaries[,max(contour.ID)]
        if(!is.finite(order.start))order.start=0
        boundaries=rbind(boundaries,
                         delaunay.points[type%in%c("out","ext"),.(p.ID,contour.ID=(1:.N)+contour.ID.start,order=(1:.N)+order.start,is.exterior=(type=="ext"),type="point")])
    }

    ##keep only exterior boundaries
    if(only.exterior)
    {
        boundaries=boundaries[is.exterior==TRUE]
    }

    if(expand>0)
    {
        ##To add p.ID of previous and next points (used to expand polygon)    
        ##duplicate first point to close the cycle
        boundaries=rbind(boundaries[,.(contour.ID,p.ID,order,is.exterior,type)],
                         boundaries[,.(p.ID=p.ID[which.min(order)],order=max(order)+1,is.exterior=is.exterior[which.min(order)],type=type[which.min(order)]),by=.(contour.ID)],
                         boundaries[,.(p.ID=p.ID[which.max(order)],order=min(order)-1,is.exterior=is.exterior[which.max(order)],type=type[which.max(order)]),by=.(contour.ID)])        
        setorder(boundaries,contour.ID,order)
        boundaries=boundaries[,.(is.exterior,type,order,p.ID,p.ID.prev=shift(p.ID,type="lag"),p.ID.next=shift(p.ID,type="lead")),by=.(contour.ID)][!is.na(p.ID.prev)&!is.na(p.ID.next)]
    }
    ##add positions and group.ID
    setkey(delaunay.points,p.ID)
    setkey(boundaries,p.ID)
    boundaries[,x:=delaunay.points[boundaries,x]]
    boundaries[,y:=delaunay.points[boundaries,y]]
    boundaries[,group:=delaunay.points[boundaries,group.ID]]

    ##### expand 
    if(expand>0)
    {
        ##add previous/next positions
        setkey(delaunay.points,p.ID)
        setkey(boundaries,p.ID.prev)
        boundaries[,x.prev:=delaunay.points[boundaries,x]]
        boundaries[,y.prev:=delaunay.points[boundaries,y]]
        setkey(boundaries,p.ID.next)
        boundaries[,x.next:=delaunay.points[boundaries,x]]
        boundaries[,y.next:=delaunay.points[boundaries,y]]
        setorder(boundaries,order)
        ##
        boundaries[,dx.prev:=(x-x.prev)]
        boundaries[,dy.prev:=(y-y.prev)]
        boundaries[,dx.next:=(x.next-x)]
        boundaries[,dy.next:=(y.next-y)]
        boundaries[,d.prev:=sqrt(dx.prev^2+dy.prev^2)]
        boundaries[,dx.prev:=dx.prev/d.prev]
        boundaries[,dy.prev:=dy.prev/d.prev]
        boundaries[,d.next:=sqrt(dx.next^2+dy.next^2)]
        boundaries[,dx.next:=dx.next/d.next]
        boundaries[,dy.next:=dy.next/d.next]

        boundaries[,dx:=(dy.next+dy.prev)] #(x,y,0)x(0,0,1)=(y,-x,0)
        boundaries[,dy:=-(dx.next+dx.prev)] #(x,y,0)x(0,0,1)=(y,-x,0)
        boundaries[,d:=sqrt(dx^2+dy^2)]
        boundaries[,dx:=expand*dx/d]
        boundaries[,dy:=expand*dy/d]
        boundaries[is.finite(dx)&is.finite(dy),x:=x+dx]
        boundaries[is.finite(dx)&is.finite(dy),y:=y+dy]
    }
    
    setorder(boundaries,group,contour.ID,order)
    ##rename contour.IDs
    tmp=boundaries[,.(contour.ID=unique(contour.ID))][,.(contour.ID,contour.ID.new=1:.N)]
    boundaries[,contour.ID:=tmp[boundaries,contour.ID.new,on="contour.ID"]]
    
    return(boundaries[,.(x,y,group,contour.ID,type)])
}


##################################
##boundary detection
##################################

if(boundary.method=="alphashape")
{
    cat(paste0("[",format(Sys.time()),"] "),"alphashape\n")
    alpha=convert.slide.to.image.length(boundary.param,image.info)
    patches.boundaries=alpha.shape(data.all[selected==TRUE&!is.na(cluster.ID),nucleus.x],data.all[selected==TRUE&!is.na(cluster.ID),nucleus.y],data.all[selected==TRUE&!is.na(cluster.ID),cluster.ID],alpha=alpha,keep.points=FALSE,only.exterior=TRUE,expand=0)
    ##rename columns
    patches.boundaries=patches.boundaries[,.(patch.ID=contour.ID,x,y)]

}
if(boundary.method=="convexhull")
{
    convexhull=function(x,y){
        ind=chull(x,y)
        return(list(x=x[ind],y=y[ind]))
    }
    patches.boundaries=data.all[selected==TRUE&!is.na(cluster.ID),convexhull(nucleus.x,nucleus.y),by=.(patch.ID=cluster.ID)]
}

##assign cells to patches.boundaries
patch.ID.multiple.assignment=-1 #patch.ID for cells assigned to multiple patches. This can happen, in particular when using clustering.method%in%c("component","louvain") and boundary.method="convexhull" (but also with "alphashape")
data.all[,patch.ID:=as.integer(NA)]
for(pid in patches.boundaries[,unique(patch.ID)])
{
    tmp=patches.boundaries[patch.ID==pid]        
    data.all[excluded==FALSE&nucleus.x<=tmp[,max(x)]&nucleus.x>=tmp[,min(x)]&nucleus.y<=tmp[,max(y)]&nucleus.y>=tmp[,min(y)],patch.ID:=ifelse(point.in.polygon(nucleus.x,nucleus.y,tmp$x,tmp$y)!=0,ifelse(is.na(patch.ID),pid,patch.ID.multiple.assignment),patch.ID)]   
}

##for cells assigned to multiple patches => assign to patch.ID of nearest uniquely assigned cell
if(data.all[,any(!is.na(patch.ID)&patch.ID==patch.ID.multiple.assignment)])
{
    idx=nn2(data.all[!is.na(patch.ID)&patch.ID!=patch.ID.multiple.assignment,.(nucleus.x,nucleus.y)],data.all[patch.ID==patch.ID.multiple.assignment,.(nucleus.x,nucleus.y)],k=1)$nn.idx[,1]
    data.all[patch.ID==patch.ID.multiple.assignment,patch.ID:=data.all[!is.na(patch.ID)&patch.ID!=patch.ID.multiple.assignment][idx,patch.ID]]
    rm(idx)
}


##Eval patches properties
patches.summary=data.all[excluded==FALSE&!is.na(patch.ID),.(n.all=.N,n.selected=sum(selected==TRUE),area=sum(area)),by=.(patch.ID)]
patches.summary[,density.all:=n.all/area]
patches.summary[,density.selected:=n.selected/area]

##filter patches
patch.ID.tokeep=patches.summary[n.all>=minimum.patch.size.all.cells&
                                n.selected>=minimum.patch.size.selected.phenotype&
                                density.all>=minimum.patch.density.all.cells&
                                density.selected>=minimum.patch.density.selected.phenotype&
                                area>=minimum.patch.area,
                                patch.ID]
data.all[!patch.ID%in%patch.ID.tokeep,patch.ID:=NA]
patches.summary=patches.summary[patch.ID%in%patch.ID.tokeep]
patches.boundaries=patches.boundaries[patch.ID%in%patch.ID.tokeep]

##renumber patch.IDs
tmp=patches.summary[,.(patch.ID=sort(unique(patch.ID)))][,.(patch.ID,patch.ID.new=1:.N)]
patches.summary[,patch.ID:=tmp[patches.summary,patch.ID.new,on="patch.ID"]]
data.all[!is.na(patch.ID),patch.ID:=tmp[data.all[!is.na(patch.ID)],patch.ID.new,on="patch.ID"]]
patches.boundaries[,patch.ID:=tmp[patches.boundaries,patch.ID.new,on="patch.ID"]]

## When reassigning cells with multiple assignment, we should also modify patches.boundaries (unless using clustering.method "none"). Alternatively, we can simply erase it:
rm(patches.boundaries)

#######################
##save data 
#######################

filename=paste0(outputdir,"/patches.RData")
cat(paste0("[",format(Sys.time()),"] "),"Saving results in",filename,"\n")
data.patches=data.all[,.(cell.ID,patch.ID)]
data.patches.summary=patches.summary
save(data.patches,data.patches.summary,minimum.local.density.all.cells.mm2,minimum.local.density.selected.phenotype.mm2,minimum.patch.density.all.cells.mm2,minimum.patch.density.selected.phenotype.mm2,minimum.patch.area.mm2,minimum.local.density.all.cells,minimum.local.density.selected.phenotype,minimum.patch.density.all.cells,minimum.patch.density.selected.phenotype,minimum.patch.area,minimum.patch.size.all.cells,minimum.patch.size.selected.phenotype,clustering.method,boundary.method,boundary.param,selected.phenotype,file=filename)
rm(data.patches)

#######################
##save summary table 
#######################
output.table=rbind(data.frame(name="Number of patches",
                              value=data.all[excluded==FALSE&!is.na(patch.ID),length(unique(patch.ID))],
                              unit="",
                              description=paste0("Number of ",gsub(",","",selected.phenotype)," patches")),
                   data.frame(name="Total patch area",
                                      value=signif(data.all[excluded==FALSE&!is.na(patch.ID),convert.image.to.slide.area(sum(area),image.info)/1e6],4),
                                      unit="mm^2",
                                      description=paste0("Total area covered by ",gsub(",","",selected.phenotype)," patches.")),
                   data.frame(name="Number of patches overlapping tumor",
                              value=data.all[excluded==FALSE&!is.na(patch.ID)&tissue.type=="tumor",length(unique(patch.ID))],
                              unit="",
                              description=paste0("Number of ",gsub(",","",selected.phenotype)," patches with at least one cell with tumor tissue type")),
                   data.frame(name="Total patch area in tumor",
                                      value=signif(data.all[excluded==FALSE&!is.na(patch.ID)&tissue.type=="tumor",convert.image.to.slide.area(sum(area),image.info)/1e6],4),
                                      unit="mm^2",
                                      description=paste0("Total area of tumor tissue type covered by ",gsub(",","",selected.phenotype)," patches.")),
                   data.frame(name="Number of patches overlapping stroma",
                              value=data.all[excluded==FALSE&!is.na(patch.ID)&tissue.type=="stroma",length(unique(patch.ID))],
                              unit="",
                              description=paste0("Number of ",gsub(",","",selected.phenotype)," patches with at least one cell with stroma tissue type")),
                   data.frame(name="Total patch area in stroma",
                                      value=signif(data.all[excluded==FALSE&!is.na(patch.ID)&tissue.type=="stroma",convert.image.to.slide.area(sum(area),image.info)/1e6],4),
                                      unit="mm^2",
                                      description=paste0("Total area of stroma tissue type covered by ",gsub(",","",selected.phenotype)," patches."))
                   )
##overlap with regions of interest
tumor_tissue_only.ROI.tokeep="Tumor tissue"
tumor_tissue_only.ROI.toremove=c("Adipose tissue","Host tissue","Necrosis","Next to tumor tissue")
if(!is.null(input.ROI))
{
    in.ROI=NULL
    for(roi.label.idx in seq_along(regions.of.interest.labels))
    {
        in.ROI.tmp=rep(FALSE,data.all[,.N])
        for(roi.id in regions.of.interest.ids[[roi.label.idx]])
            in.ROI.tmp=in.ROI.tmp|(point.in.polygon(data.all$nucleus.x,data.all$nucleus.y,regions.of.interest[id==roi.id,x],regions.of.interest[id==roi.id,y])!=0)
        if(is.null(in.ROI))
        {
            in.ROI=data.table(in.ROI.tmp)
        }
        else
        {
            in.ROI=cbind(in.ROI,in.ROI.tmp)
        }
    }
    setnames(in.ROI,paste0("in.ROI.",seq_along(regions.of.interest.labels)))
    data.all=cbind(data.all,in.ROI)
    ##add a column in.ROI._tumor_tissue_only_ that flag cell inside tumor tissue but not inside "Adipose tissue", "Host tissue", "Necrosis" nor "Next to tumor tissue"
    if(tumor_tissue_only.ROI.tokeep%in%regions.of.interest.labels)
    {
        tumor.idx=match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels)
        data.all[,in.ROI._tumor_tissue_only_:=.SD,.SDcols=paste0("in.ROI.",tumor.idx)]
        for(roi.label in tumor_tissue_only.ROI.toremove)
        {
            if(roi.label%in%regions.of.interest.labels)
            {
                roi.label.idx=match(roi.label,regions.of.interest.labels)
                data.all[,in.ROI._tumor_tissue_only_:=ifelse(.SD==TRUE,FALSE,in.ROI._tumor_tissue_only_),.SDcols=paste0("in.ROI.",roi.label.idx)]
            }
        }
    }
    else
    {
        ##no ROI "Tumor tissue"
        data.all[,in.ROI._tumor_tissue_only_:=FALSE]
    }
    for(roi.label.idx in seq_along(regions.of.interest.labels))
    {
        data.all[,in.ROI.tmp:=.SD,.SDcols=paste0("in.ROI.",roi.label.idx)]
        output.table=rbind(output.table,
                           data.frame(name=paste0("Number of patches overlapping ROI ",str_sanitize_path(tolower(regions.of.interest.labels[roi.label.idx]))),
                                      value=data.all[excluded==FALSE&!is.na(patch.ID)&in.ROI.tmp==TRUE,length(unique(patch.ID))],
                                      unit="",
                                      description=paste0("Number of ",gsub(",","",selected.phenotype)," patches with at least one cell in ROI ",str_sanitize_path(tolower(regions.of.interest.labels[roi.label.idx]))," (",regions.of.interest.labels[roi.label.idx],")")),
                           data.frame(name=paste0("Total patch area in ROI ",str_sanitize_path(tolower(regions.of.interest.labels[roi.label.idx]))),
                                      value=signif(data.all[excluded==FALSE&!is.na(patch.ID)&in.ROI.tmp==TRUE,convert.image.to.slide.area(sum(area),image.info)/1e6],4),
                                      unit="mm^2",
                                      description=paste0("Total area of ROI ",str_sanitize_path(tolower(regions.of.interest.labels[roi.label.idx]))," (",regions.of.interest.labels[roi.label.idx],") covered by ",gsub(",","",selected.phenotype)," patches.")))
        data.all[,in.ROI.tmp:=NULL]
    }
    if(tumor_tissue_only.ROI.tokeep%in%regions.of.interest.labels)
    {
        data.all[,in.ROI.tmp:=in.ROI._tumor_tissue_only_]
        if(any(tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels))
        {
            output.table=rbind(output.table,
                               data.frame(name=paste0("Number of patches overlapping ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," only"),
                                          value=data.all[excluded==FALSE&!is.na(patch.ID)&in.ROI.tmp==TRUE,length(unique(patch.ID))],
                                          unit="",
                                          description=paste0("Number of ",gsub(",","",selected.phenotype)," patches with at least one cell in ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," (",tumor_tissue_only.ROI.tokeep,") and not in ",paste(paste0(str_sanitize_path(tolower(tumor_tissue_only.ROI.toremove[tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels]))," (",tumor_tissue_only.ROI.toremove[tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels],")"),collapse=", "))),
                               data.frame(name=paste0("Total patch area in ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," only"),
                                          value=signif(data.all[excluded==FALSE&!is.na(patch.ID)&in.ROI.tmp==TRUE,convert.image.to.slide.area(sum(area),image.info)/1e6],4),
                                          unit="mm^2",
                                          description=paste0("Total area of ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," (",tumor_tissue_only.ROI.tokeep,") without ROI ",paste(paste0(str_sanitize_path(tolower(tumor_tissue_only.ROI.toremove[tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels]))," (",tumor_tissue_only.ROI.toremove[tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels],")"),collapse=", ")," covered by ",gsub(",","",selected.phenotype)," patches.")))
        }
        else
        {
            output.table=rbind(output.table,
                               data.frame(name=paste0("Number of patches overlapping ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," only"),
                                          value=data.all[excluded==FALSE&!is.na(patch.ID)&in.ROI.tmp==TRUE,length(unique(patch.ID))],
                                          unit="",
                                          description=paste0("Number of ",gsub(",","",selected.phenotype)," patches with at least one cell in ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," (",tumor_tissue_only.ROI.tokeep,")")),
                               data.frame(name=paste0("Total patch area in ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," only"),
                                          value=signif(data.all[excluded==FALSE&!is.na(patch.ID)&in.ROI.tmp==TRUE,convert.image.to.slide.area(sum(area),image.info)/1e6],4),
                                          unit="mm^2",
                                          description=paste0("Total area of ROI ",str_sanitize_path(tolower(tumor_tissue_only.ROI.tokeep))," (",tumor_tissue_only.ROI.tokeep,") covered by ",gsub(",","",selected.phenotype)," patches.")))
        }
        data.all[,in.ROI.tmp:=NULL]
    }
    
}

filename=paste0(outputdir,"/summary.tsv")
cat("creating",filename,"\n")
fwrite(output.table,file=filename,sep="\t",na="NA",quote=FALSE,row.names=FALSE)


############################################
##prepare input file for each tile
############################################
if((!is.null(outputdir.patch.mask))||(!is.null(outputdir.selected.mask)))
{
    tile.size=5000
    tiles.x=lapply(0:floor(image.info$image.width.pixel/tile.size),function(i){
        c(x=i*tile.size,width=min(tile.size,image.info$image.width.pixel-i*tile.size))
    })
    tiles.y=lapply(0:floor(image.info$image.height.pixel/tile.size),function(i){
        c(y=i*tile.size,height=min(tile.size,image.info$image.height.pixel-i*tile.size))
    })
    ##keep only tiles with finite sizes
    tiles.x=tiles.x[sapply(tiles.x,function(x){x["width"]>0})]
    tiles.y=tiles.y[sapply(tiles.y,function(x){x["height"]>0})]
    ##by rows
    tiles=unlist(lapply(tiles.y,function(t.y){
        lapply(tiles.x,function(t.x){
            c(t.x,t.y)
        })
    }),recursive=FALSE)

    ##add n
    for(n in 1:length(tiles))
        tiles[[n]]=c(tiles[[n]],n=n)

    for(tile in tiles)
    {
        
        cids=voronoi.cells[x>=tile["x"]&x<=tile["x"]+tile["width"]&y>=tile["y"]&y<=tile["y"]+tile["height"],unique(cell.ID)]
        
        filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],"_voronoi.rds")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")    
        saveRDS(voronoi.cells[cell.ID%in%cids],filename)
        
        filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],"_data.rds")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")    
        saveRDS(data.all[cell.ID%in%cids,.(cell.ID,patch.ID,selected)],filename)        
    }
    cl <- makeCluster(nprocesses,outfile="")
    clusterEvalQ(cl, {
        library(data.table)
        setDTthreads(1)
        options(scipen=13)
    })
    clusterExport(cl, c("tmpdir","outputdir.patch.mask","outputdir.selected.mask"))

}

#######################
##save Patches as image mask
#######################
if(!is.null(outputdir.patch.mask))
{

    dir.create(outputdir.patch.mask,showWarnings=FALSE,recursive=TRUE)
    invisible(parLapply(cl,tiles,function(tile){

        ##load data
        input.filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],"_voronoi.rds")
        cat(paste0("[",format(Sys.time()),"] "),"reading",input.filename,"\n")    
        voronoi.cells=readRDS(input.filename)
        input.filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],"_data.rds")
        cat(paste0("[",format(Sys.time()),"] "),"reading",input.filename,"\n")    
        data.all=readRDS(input.filename)

        cids.patches=data.all[!is.na(patch.ID),unique(cell.ID)]
        
        w=tile["width"]
        h=tile["height"]

        filename=paste0(outputdir.patch.mask,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],".png")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        png(filename,width=w,height=h)
        par(mar=c(0,0,0,0),bg = "black")
        plot(NA,xlim=c(-0.5,w-0.5),ylim=c(h-0.5,-0.5),xaxs="i",yaxs="i",xaxt="n",yaxt="n",type="n",xlab="",ylab="",bty="n")
        
        ##keep only voronoi cells touching the tile
        cids=voronoi.cells[x>=tile["x"]&x<=tile["x"]+tile["width"]&y>=tile["y"]&y<=tile["y"]+tile["height"],unique(cell.ID)]
        ##keep only cells in patches
        cids=cids[cids%in%cids.patches]

        with_border=TRUE
        border.col=rgb(0.5,0.5,0.5)
        fill.col="white"
        if(with_border)
        {
            ##slower, but draw "border"
            invisible(lapply(data.all[cell.ID%in%cids,unique(patch.ID)],function(pid){
                cids2=data.all[patch.ID==pid,unique(cell.ID)]
                polygon(voronoi.cells[cell.ID%in%cids2,.(x=c(x,NA),y=c(y,NA)),by=cell.ID][,.(x-tile["x"],y-tile["y"])],border=border.col,col=fill.col,lwd=4)
                ##Draw "interior"
                ##insert NA between consecutive cells
                polygon(voronoi.cells[cell.ID%in%cids2,.(x=c(x,NA),y=c(y,NA)),by=cell.ID][,.(x-tile["x"],y-tile["y"])],border=NA,col=fill.col)
            }))
        }
        else
        {
            ##faster, but no border
            ##insert NA between consecutive cells
            polygon(voronoi.cells[cell.ID%in%cids,.(x=c(x,NA),y=c(y,NA)),by=cell.ID][,.(x=x-tile["x"],y=y-tile["y"])],border=NA,col=fill.col)
        }

        dev.off()

    }))
}


#######################
##save selected cells as image mask
#######################
if(!is.null(outputdir.selected.mask))
{

    dir.create(outputdir.selected.mask,showWarnings=FALSE,recursive=TRUE)
    invisible(parLapply(cl,tiles,function(tile){
        
        ##load data
        input.filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],"_voronoi.rds")
        cat(paste0("[",format(Sys.time()),"] "),"reading",input.filename,"\n")    
        voronoi.cells=readRDS(input.filename)
        input.filename=paste0(tmpdir,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],"_data.rds")
        cat(paste0("[",format(Sys.time()),"] "),"reading",input.filename,"\n")    
        data.all=readRDS(input.filename)

        cids.cells=data.all[selected==TRUE,unique(cell.ID)]

        w=tile["width"]
        h=tile["height"]

        filename=paste0(outputdir.selected.mask,"/tile_",sprintf("%09d", tile[["n"]]),"_",tile[["x"]],"_",tile[["y"]],".png")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        png(filename,width=w,height=h)
        par(mar=c(0,0,0,0),bg = "black")
        plot(NA,xlim=c(-0.5,w-0.5),ylim=c(h-0.5,-0.5),xaxs="i",yaxs="i",xaxt="n",yaxt="n",type="n",xlab="",ylab="",bty="n")
        
        ##keep only voronoi cells touching the tile
        cids=voronoi.cells[x>=tile["x"]&x<=tile["x"]+tile["width"]&y>=tile["y"]&y<=tile["y"]+tile["height"],unique(cell.ID)]
        ##keep only cells in patches
        cids=cids[cids%in%cids.cells]
        ##insert NA between consecutive cells
        polygon(voronoi.cells[cell.ID%in%cids,.(x=c(x,NA),y=c(y,NA)),by=cell.ID][,.(x=x-tile["x"],y=y-tile["y"])],border=NA,col="white")

        dev.off()

    }))
}

if((!is.null(outputdir.patch.mask))||(!is.null(outputdir.selected.mask)))
{
    stopCluster(cl)
}


clean()
cat(paste0("[",format(Sys.time()),"] "),"Done\n")
