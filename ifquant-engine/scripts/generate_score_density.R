#!/usr/bin/env Rscript

## Copyright (C) 2022 Julien Dorier and UNIL (University of Lausanne).
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <https://www.gnu.org/licenses/>.

##########################################
#parse command line options
##########################################

args=commandArgs(trailingOnly = TRUE)

library(optparse)

usage="
  %prog [options] merge_cells_RData tissue_segmentation_RData"

description="
Positional arguments:
\tmerge_cells_RData
\t\tRData file generated by merge_cells.R.
\ttissue_segmentation_RData
\t\tRData file generated by tissue_segmentation.R.
"

epilogue=""

#default=NA => mandatory, default=NULL => optional.
option_list=list(
    make_option(c("--nprocesses"), type="integer", default=1,metavar="N",
                help="Max number of threads to use (only for data.table) [default %default]."),
    make_option(c("--thresholds"), type="character", default=NULL,metavar="FILENAME",
                help="File with channel thresholding information.
\t\tTab separated file with header in the first row and at least 4 columns:
\t\t * channel: channel number (0, 1, 2, ...).
\t\t * name: channel name (DAPI, CD15,... must correspond to metadata).
\t\t * score.type: score type
\t\t    should have the form <summary_statistic>.<region> with
\t\t    <summary_statistic>=mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050
\t\t     where q<n> is the n-th percentile and circular.q<n> is the n-th percentile of max in all directions.
\t\t    <region>=nucleus, extended.nucleus or around.nucleus
\t\t    e.g. mean.nucleus, median.extended.nucleus, q001.nucleus, q095.around.nucleus, circular.q010.around.nucleus
\t\t * threshold: numeric threshold. A cell is \"positive\" for a channel if its score is above threshold.
\t\tIf not specified: use thresholds saved in tissue_segmentation_RData."),
    make_option(c("--excluded-regions"), type="character", default=NULL,metavar="FILENAME",
                help="File with excluded regions (closed polygons).
\t\tComma separated format with header in the first row and 3 columns: id, x and y.
\t\tThis file can contain multiple polygons, each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point.
\t\tAll cells with center inside an excluded region will be ignored."),
    make_option(c("--transformation"), type="character", default="sqrt",metavar="T",
                help="Transform channel scores with transformation T [default %default].
\t\tPossible values:
\t\t * none
\t\t * sqrt
\t\t * asinh"),
    make_option(c("--output-resolution"), type="integer", default=256,metavar="N",
                help="Output resolution (NxN pixels) [default %default]."),
    make_option(c("--output"), type="character", default=NA,metavar="DIRNAME",
                help="Output directory [mandatory].
\t\tTwo files will be created per pair of channels:
\t\t * density_<channel1>_<channel2>.png: pairwise score density plot for channels <channel2> (y-axis) vs <channel1> (x-axis).
\t\t * <channel1>_<channel2>_metadata.txt: metadata with a description of the plot axis.")
)


opt=parse_args(OptionParser(option_list=option_list,
                            usage=usage,
                            description=description,
                            epilogue=epilogue
                            ),positional_arguments=2,args=args)

##check all options are set, and print them
for(o in option_list)
{
    n=slot(o,"dest")
    f=c(slot(o,"short_flag"),slot(o,"long_flag"))
    f=paste(f[!is.na(f)],sep=",")
    if(!is.null(opt$options[[n]])) ##Default NULL => optional.
    {
        if(is.na(opt$options[[n]])) ##Default NA => mandatory
            stop("option ",f," is mandatory")
        ##check type
        if(typeof(opt$options[[n]])!=slot(o,"type"))
            stop("option ",f," must be ",slot(o,"type"))
        ##print
        if(slot(o,"action")!="store_true")
            cat(slot(o,"long_flag"),"=",opt$options[[n]],"\n",sep="")
        if(slot(o,"action")=="store_true"&&opt$options[[n]]==TRUE)
            cat(slot(o,"long_flag"),"\n",sep="")
    }
}
cat("positional arguments: ",paste(opt$args,collapse=" "),"\n",sep="")

nprocesses=opt$options[["nprocesses"]]
input.thresholding=opt$options[["thresholds"]]
input.excluded.regions=opt$options[["excluded-regions"]]
transformation.str=opt$options[["transformation"]]
output.resolution=opt$options[["output-resolution"]]
outputdir=opt$options[["output"]]

##check
if(!(is.finite(nprocesses)&nprocesses>0))
{
    stop("--nprocesses must be a positive integer")
}

##positional arguments
input_merge_cells.RData=opt$args[1]
input_tissue_segmentation.RData=opt$args[2]


dir.create(outputdir,showWarnings=FALSE,recursive=TRUE)
library(data.table)
library(sp) #point.in.polygon
library(ggplot2)
library(viridis)

options(scipen=13)

setDTthreads(nprocesses)



############################################
##load
############################################

cat(paste0("[",format(Sys.time()),"] "),"loading",input_merge_cells.RData,"\n")
load(input_merge_cells.RData)
image.info.tmp=image.info
metadata.tmp=metadata

cat(paste0("[",format(Sys.time()),"] "),"loading",input_tissue_segmentation.RData,"\n")
load(input_tissue_segmentation.RData)

##simple check
if(!identical(image.info.tmp,image.info))
{
    stop("inconsistent image.info in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}
if(!identical(metadata.tmp,metadata))
{
    stop("inconsistent metadata in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}

if(!is.null(input.thresholding))
{
    cat(paste0("[",format(Sys.time()),"] "),"loading",input.thresholding,"\n")
    metadata.channel.thresholding.tmp=read.table(input.thresholding,header=TRUE,stringsAsFactors=FALSE,sep="\t")
    metadata.channel.thresholding.tmp=metadata.channel.thresholding.tmp[order(metadata.channel.thresholding.tmp$channel),]
    rownames(metadata.channel.thresholding.tmp)=paste0("channel_",metadata.channel.thresholding.tmp$channel)
    ##check
    channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
    if(!all(metadata.channel.thresholding[channels,"channel"]==metadata.channel.thresholding.tmp[channels,"channel"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(metadata.channel.thresholding[channels,"name"]==metadata.channel.thresholding.tmp[channels,"name"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(c("score.type","threshold")%in%colnames(metadata.channel.thresholding.tmp)))
    {
        stop("Invalid",input.thresholding)
    }
    ##replace
    metadata.channel.thresholding=metadata.channel.thresholding.tmp
}

############################################
## check
############################################
if(is.null(nucleusFeatures.image)) ##i.e. 0 cells
{
    cat(paste0("[",format(Sys.time()),"] "),"0 cell found. Aborting...\n")

    channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
    nbins=output.resolution
    for(pair in combn(channels,2,simplify=FALSE))
    {
        channel.x=pair[1]
        channel.y=pair[2]
        channel.x.name=metadata[channel.x,"name"]
        channel.y.name=metadata[channel.y,"name"]


        ##save image
        filename=paste0(outputdir,"/density_",metadata[channel.x,"channel"],"_",metadata[channel.y,"channel"],".png")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        png(filename,nbins,nbins)
        par(mar=c(0, 0, 0, 0),bty="n",oma=c(0,0,0,0))
        plot(NA,type="n",xlim=c(0,1),ylim=c(0,1),xlab="",ylab="",xaxt="n",yaxt="n",xaxs="i",yaxs="i")
        dev.off()

        filename=paste0(outputdir,"/metadata_",metadata[channel.x,"channel"],"_",metadata[channel.y,"channel"],".txt")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        tmp=data.table(V1="channel.x",V2=channel.x.name)
        tmp=rbind(tmp,data.table(V1="channel.y",V2=channel.y.name))
        tmp=rbind(tmp,data.table(V1="score.x.max",V2=NA))
        tmp=rbind(tmp,data.table(V1="score.y.max",V2=NA))
        if(transformation.str=="sqrt")
        {
            tmp=rbind(tmp,data.table(V1="score.x",V2="score.x.max*x^2"))
            tmp=rbind(tmp,data.table(V1="score.y",V2="score.y.max*y^2"))
            tmp=rbind(tmp,data.table(V1="x",V2="sqrt(score.x/score.x.max)"))
            tmp=rbind(tmp,data.table(V1="y",V2="sqrt(score.y/score.y.max)"))
        }
        else if(transformation.str=="asinh")
        {
            tmp=rbind(tmp,data.table(V1="score.x",V2="sinh(x*asinh(score.x.max))"))
            tmp=rbind(tmp,data.table(V1="score.y",V2="sinh(y*asinh(score.y.max))"))
            tmp=rbind(tmp,data.table(V1="x",V2="asinh(score.x)/asin(score.x.max)"))
            tmp=rbind(tmp,data.table(V1="y",V2="asinh(score.y)/asin(score.y.max)"))
        }
        else
        {
            tmp=rbind(tmp,data.table(V1="score.x",V2="score.x.max*x"))
            tmp=rbind(tmp,data.table(V1="score.y",V2="score.y.max*y"))
            tmp=rbind(tmp,data.table(V1="x",V2="score.x/score.x.max"))
            tmp=rbind(tmp,data.table(V1="y",V2="score.y/score.y.max"))
        }
        fwrite(tmp,file=filename,sep="=",na="NA",quote=FALSE,row.names=FALSE,col.names=FALSE)
    }
    cat(paste0("[",format(Sys.time()),"] "),"Done\n")
    quit()
}

############################################
##load excluded region
############################################

excluded.regions=data.table(id=integer(0))
if(!is.null(input.excluded.regions))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.excluded.regions,"\n")
    excluded.regions=fread(input.excluded.regions)
}

############################################
## flag cells to filter out
############################################

to.keep=rep(TRUE,nrow(nucleusFeatures.image[["shape"]]))
if(!is.null(input.excluded.regions))
{
    ##exclude points
    for(i in excluded.regions[,unique(id)])
        to.keep=to.keep&(point.in.polygon(nucleusFeatures.image[["shape"]][,"nucleus.x"],nucleusFeatures.image[["shape"]][,"nucleus.y"],excluded.regions[id==i,x],excluded.regions[id==i,y])==0)

}

############################################
## Evaluate score
############################################

data.score=NULL
for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    score.type=metadata.channel.thresholding[f,"score.type"]
    threshold=metadata.channel.thresholding[f,"threshold"]
    ##split score.type into summary statistic and region
    score.type.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",score.type)
    score.type.statistic=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",score.type)
    ##check
    if(!score.type.region%in%c("nucleus","extended.nucleus","around.nucleus"))
        stop("Invalid score type",score.type,". Accepted regions: nucleus, extended.nucleus or around.nucleus")
    if(!score.type.statistic%in%c("mean","median","q001","q005","q025","q075","q095","q099","circular.q005","circular.q010","circular.q025","circular.q050"))
        stop("Invalid score type ",score.type,". Accepted summary statistics: mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050")
    if(score.type.statistic=="median")score.type.statistic="q050"

    if(score.type.region=="nucleus")
    {
        data.score=cbind(data.score,nucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="extended.nucleus")
    {
        data.score=cbind(data.score,extendedNucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="around.nucleus")
    {
        data.score=cbind(data.score,aroundNucleusFeatures.image[[f]][,score.type.statistic])
    }
}
cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
colnames(data.score)=cols


set.seed(12734)

############################################
##transformation
############################################
score.transfo=function(x){x}
score.transfo.inv=function(x){x}
if(transformation.str=="sqrt")
{
    score.transfo=function(x){sign(x)*sqrt(abs(x))}
    score.transfo.inv=function(x){sign(x)*x**2}
}
if(transformation.str=="asinh")
{
    score.transfo=function(x){asinh(x)}
    score.transfo.inv=function(x){sinh(x)}
}


############################################
##export score density
############################################

channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
nbins=output.resolution
for(pair in combn(channels,2,simplify=FALSE))
{
    channel.x=pair[1]
    channel.y=pair[2]
    channel.x.name=metadata[channel.x,"name"]
    channel.y.name=metadata[channel.y,"name"]

    data=setnames(data.table(data.score[to.keep,c(channel.x,channel.y),drop=FALSE]),c("score.x","score.y"))
    ##tranform
    data[,score.x:=score.transfo(score.x)]
    data[,score.y:=score.transfo(score.y)]

    range.x=c(0,data[,max(score.x,na.rm=TRUE)])
    range.y=c(0,data[,max(score.y,na.rm=TRUE)])

    ##save metadata
    filename=paste0(outputdir,"/metadata_",metadata[channel.x,"channel"],"_",metadata[channel.y,"channel"],".txt")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    tmp=data.table(V1="channel.x",V2=channel.x.name)
    tmp=rbind(tmp,data.table(V1="channel.y",V2=channel.y.name))
    tmp=rbind(tmp,data.table(V1="score.x.max",V2=score.transfo.inv(range.x[2])))
    tmp=rbind(tmp,data.table(V1="score.y.max",V2=score.transfo.inv(range.y[2])))
    if(transformation.str=="sqrt")
    {
        tmp=rbind(tmp,data.table(V1="score.x",V2="score.x.max*x^2"))
        tmp=rbind(tmp,data.table(V1="score.y",V2="score.y.max*y^2"))
        tmp=rbind(tmp,data.table(V1="x",V2="sqrt(score.x/score.x.max)"))
        tmp=rbind(tmp,data.table(V1="y",V2="sqrt(score.y/score.y.max)"))
    }
    else if(transformation.str=="asinh")
    {
        tmp=rbind(tmp,data.table(V1="score.x",V2="sinh(x*asinh(score.x.max))"))
        tmp=rbind(tmp,data.table(V1="score.y",V2="sinh(y*asinh(score.y.max))"))
        tmp=rbind(tmp,data.table(V1="x",V2="asinh(score.x)/asin(score.x.max)"))
        tmp=rbind(tmp,data.table(V1="y",V2="asinh(score.y)/asin(score.y.max)"))
    }
    else
    {
        tmp=rbind(tmp,data.table(V1="score.x",V2="score.x.max*x"))
        tmp=rbind(tmp,data.table(V1="score.y",V2="score.y.max*y"))
        tmp=rbind(tmp,data.table(V1="x",V2="score.x/score.x.max"))
        tmp=rbind(tmp,data.table(V1="y",V2="score.y/score.y.max"))
    }

    fwrite(tmp,file=filename,sep="=",na="NA",quote=FALSE,row.names=FALSE,col.names=FALSE)

    ##save image
    bx=(range.x[2]-range.x[1])/output.resolution
    by=(range.y[2]-range.y[1])/output.resolution
    if(bx<1e-8)bx=1e-8
    if(by<1e-8)by=1e-8
    colors=c("white","#31133D","#28BBEC","#A2FD3C","#FB8022","#7B0403") #turbo
    filename=paste0(outputdir,"/density_",metadata[channel.x,"channel"],"_",metadata[channel.y,"channel"],".png")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    png(filename,nbins,nbins)
    par(mar=c(0, 0, 0, 0),bty="n",oma=c(0,0,0,0))
    smoothScatter(data$score.x,data$score.y,xlab="",ylab="",colramp=colorRampPalette(colors),bandwidth=c(bx,by),nbin=output.resolution,xaxt="n",yaxt="n",xlim=range.x,ylim=range.y,xaxs="i",yaxs="i",useRaster=TRUE,nrpoints=0)
    dev.off()
}



cat(paste0("[",format(Sys.time()),"] "),"Done\n")
