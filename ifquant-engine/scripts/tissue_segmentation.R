#!/usr/bin/env Rscript

## Copyright (C) 2022 Julien Dorier and UNIL (University of Lausanne).
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <https://www.gnu.org/licenses/>.

##########################################
#parse command line options
##########################################

args=commandArgs(trailingOnly = TRUE)

library(optparse)

usage="
  %prog [options] merge_cells_RData"

description="
Positional arguments:
\tmerge_cells_RData
\t\tRData file generated by merge_cells.R."

epilogue="Notes:
 - bfconvert and showinf must be in the PATH (bftools https://www.openmicroscopy.org/bio-formats/)
 - Channel with tumor staining (e.g. CK) used for tissue classification is found by by matching the string \"tumor\" to column \"type\" of the panel metadata (metadata loaded from inputRData). In this help message, we refer to this channel as <tumor_marker>.
 - initial tissue segmentation will be based on --thresholds. If specified, --tumor-marker-score-type and/or --tumor-marker-threshold will by used instead of --thresholds
"

#default=NA => mandatory, default=NULL => optional.
option_list=list(
    make_option(c("--tmpdir"), type="character", default=NULL,metavar="DIRNAME",
                help="Directory to save temporary images [Default R tempdir()].
\t\tConsider using /dev/shm/."),
    make_option(c("--nprocesses"), type="integer", default=1,metavar="N",
                help="Max number of threads to use (only for data.table) [default %default]."),
    make_option(c("--thresholds"), type="character", default=NULL,metavar="FILENAME",
                help="File with channel thresholding information.
\t\tTab separated file with header in the first row and at least 4 columns:
\t\t * channel: channel number (0, 1, 2, ...).
\t\t * name: channel name (DAPI, CD15,... must correspond to metadata).
\t\t * score.type: score type
\t\t    should have the form <summary_statistic>.<region> with
\t\t    <summary_statistic>=mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050
\t\t     where q<n> is the n-th percentile and circular.q<n> is the n-th percentile of max in all directions.
\t\t    <region>=nucleus, extended.nucleus or around.nucleus
\t\t    e.g. mean.nucleus, median.extended.nucleus, q001.nucleus, q095.around.nucleus, circular.q010.around.nucleus
\t\t * threshold: numeric threshold. A cell is \"positive\" for a channel if its score is above threshold.
\t\tIf not specified: use thresholds saved in tissue_segmentation_RData.
\t\tNote: score.type and threshold for <tumor_marker> will be ignored if --tumor-marker-score-type and --tumor-marker-threshold are specified."),
    make_option(c("--tumor-marker-score-type"), type="character", default=NULL,metavar="S",
                help="Score type used to classify cells as <tumor_marker> positive.
\t\tS should have the form <summary_statistic>.<region> with
\t\t <summary_statistic>=mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050
\t\t  where q<n> is the n-th percentile and circular.q<n> is the n-th percentile of max in all directions.
\t\t <region>=nucleus, extended.nucleus or around.nucleus
\t\t e.g. mean.nucleus, median.extended.nucleus, q001.nucleus, q095.around.nucleus, circular.q010.around.nucleus.
\t\tIf not given: use score.type specified in --thresholds."),
    make_option(c("--tumor-marker-threshold"), type="numeric", default=NULL,metavar="THRESHOLD",
                help="Used for tissue classification: a cell is <tumor_marker> positive (tumor) if its score in channel <tumor_marker> is above THRESHOLD.
\t\tIf not given: use threshold specified in --thresholds."),
    make_option(c("--max-cell-radius"), type="integer", default=20,metavar="R",
                help="Maximum cell radius in microns [default %default].
\t\tUsed in tissue segmentation to shrink voronoi cells and limit cell area"),
    make_option(c("--max-connectivity-dist"), type="integer", default=NULL,metavar="D",
                help="Maximum distance (in micron) between two nucleus centers linked by a delaunay
\t\tedge to beconsidered as \"connected\" [Default to --max-cell-radius*2].
\t\tUsed to define groups of connected cells with same tissue type."),
    make_option(c("--S1"), type="integer", default=5,metavar="N",
                help="Used in tissue classification [default %default]."),
    make_option(c("--S2"), type="integer", default=10,metavar="N",
                help="Used in tissue classification [default %default].
\t\tCells are initially classified as tissue type \"tumor\" or \"stroma\" based on
\t\twhether or not <tumor_marker> score is above threshold.
\t\tIn the delaunay graph (without edges of length > 2*max-cell-radius),
\t\tsmall (with up to --S1 cells) connected groups of cells with same tissue type
\t\twill have their tissue type changed (\"tumor\" <-> \"stroma\") if they are
\t\tconnected to a large (more than --S2 cells)  connected groups of cells with
\t\tthe other tissue type.
\t\tFinally, small (with up to --S1 cells) groups of cells disconnected from the
\t\tother cells are classified as \"other\"."),
    make_option(c("--output"), type="character", default=NA,metavar="DIRNAME",
                help="Output directory [mandatory].")
)


opt=parse_args(OptionParser(option_list=option_list,
                            usage=usage,
                            description=description,
                            epilogue=epilogue
                            ),positional_arguments=1,args=args)

##check all options are set, and print them
for(o in option_list)
{
    n=slot(o,"dest")
    f=c(slot(o,"short_flag"),slot(o,"long_flag"))
    f=paste(f[!is.na(f)],sep=",")
    if(!is.null(opt$options[[n]])) ##Default NULL => optional.
    {
        if(is.na(opt$options[[n]])) ##Default NA => mandatory
            stop("option ",f," is mandatory")
        ##check type
        if(typeof(opt$options[[n]])!=slot(o,"type"))
            stop("option ",f," must be ",slot(o,"type"))
        ##print
        if(slot(o,"action")!="store_true")
            cat(slot(o,"long_flag"),"=",opt$options[[n]],"\n",sep="")
        if(slot(o,"action")=="store_true"&&opt$options[[n]]==TRUE)
            cat(slot(o,"long_flag"),"\n",sep="")
    }
}
cat("positional arguments: ",paste(opt$args,collapse=" "),"\n",sep="")

tmpdir=opt$options[["tmpdir"]]
nprocesses=opt$options[["nprocesses"]]
input.thresholding=opt$options[["thresholds"]]
score.type.ck=opt$options[["tumor-marker-score-type"]]
threshold.ck.positive=opt$options[["tumor-marker-threshold"]]
max.cell.radius.micron=opt$options[["max-cell-radius"]]
max.connectivity.distance.micron=opt$options[["max-connectivity-dist"]]
small.component.size.threshold=opt$options[["S1"]]
large.component.size.threshold=opt$options[["S2"]]
outputdir=opt$options[["output"]]

##check
if(is.null(tmpdir))
{
    tmpdir=tempdir()
    cat("using tmpdir=",tmpdir,"\n",sep="")
}
if(!(is.finite(nprocesses)&nprocesses>0))
{
    stop("--nprocesses must be a positive integer")
}
if(is.null(max.connectivity.distance.micron))
{
    max.connectivity.distance.micron=2*max.cell.radius.micron
}

if(is.null(input.thresholding)&&(is.null(score.type.ck)||is.null(threshold.ck.positive)))
{
    stop("Either option --thresholds or both --tumor-marker-score-type and --tumor-marker-threshold must be specified.")
}


##positional arguments
input.RData=opt$args[1]



dir.create(outputdir,showWarnings=FALSE,recursive=TRUE)
library(parallel)
ncpu=detectCores()
detach("package:parallel", unload=TRUE)

library(data.table) 
library(viridis) #color palettes
library(EBImage)
library(gplots) #for textplot, col2hex
library(ggplot2)
library(KernSmooth)#for bkde2D
library(RColorBrewer)
library(geometry)
library(igraph)
library(RANN)#alternatively library(nabor)
options(scipen=13)

#nb threads for data.table
setDTthreads(nprocesses)

##temporary directory
tmpdir=paste0(tempfile(pattern="tmp",tmpdir=tmpdir),"/")
dir.create(tmpdir,showWarnings=FALSE,recursive=TRUE)

##temporary directory cleaning
clean=function(){
    cat(paste0("[",format(Sys.time()),"] "),"removing",tmpdir,"\n")
    unlink(tmpdir, recursive=TRUE)
}
##erase temporary directory on error    
if(!interactive())
    options(error=function(){clean();quit(status = 1)})




############################################
##load
############################################

cat(paste0("[",format(Sys.time()),"] "),"loading",input.RData,"\n")
load(input.RData)

##just in case we load an older version of input.RData without clip.region
if(!exists("clip.region"))
    clip.region=c(x.min=0,y.min=0,x.max=image.info$image.width.pixel,y.max=image.info$image.height.pixel)

cat(paste0("[",format(Sys.time()),"] "),"loading",input.thresholding,"\n")
metadata.channel.thresholding=read.table(input.thresholding,header=TRUE,stringsAsFactors=FALSE,sep="\t")
##check
if(!all(paste0("channel_",metadata.channel.thresholding$channel)%in%rownames(metadata)))
{
    stop("Invalid",input.thresholding," (invalid channel number)")
}
if(any(duplicated(metadata.channel.thresholding$channel)))
{
    stop("Invalid",input.thresholding," (duplicated channel number)")
}
rownames(metadata.channel.thresholding)=paste0("channel_",metadata.channel.thresholding$channel)
if(!all(metadata[rownames(metadata.channel.thresholding),"name"]==metadata.channel.thresholding$name))
{
    stop("Invalid",input.thresholding," (column name)")
}
if(!all(c("score.type","threshold")%in%colnames(metadata.channel.thresholding)))
{
    stop("Invalid",input.thresholding)
}
metadata.channel.thresholding=metadata.channel.thresholding[order(metadata.channel.thresholding$channel),]

input.ck=rownames(metadata)[sapply(strsplit(metadata$type,","),function(x){"tumor"%in%x})]
ck.channel.name=metadata[input.ck,"name"]
tumor_marker_present=(length(input.ck)>0)
if(tumor_marker_present==FALSE)
{
    ck.channel.name="MISSINGTUMORMARKER"
}


##Update score.type and threshold for CK in metadata.channel.thresholding 
if(!is.null(score.type.ck))
{
    metadata.channel.thresholding[input.ck,"score.type"]=score.type.ck
}
score.type.ck=metadata.channel.thresholding[input.ck,"score.type"]
if(!is.null(threshold.ck.positive))
{
    metadata.channel.thresholding[input.ck,"threshold"]=threshold.ck.positive
}
threshold.ck.positive=metadata.channel.thresholding[input.ck,"threshold"]


############################################
## check
############################################

if(is.null(nucleusFeatures.image)) ##i.e. 0 cells
{
    cat(paste0("[",format(Sys.time()),"] "),"0 cell found. Aborting...\n")
    cat(paste0("[",format(Sys.time()),"] "),ck.channel.name,"channel score distribution (quantiles=0%,1%,10%,50%,90%,99%,100%):",paste(quantile(0,probs=c(0,0.01,0.1,0.5,0.9,0.99,1)),collapse=","),"\n")

    ##save RData
    voronoi.cells.summary=data.table(cell.ID=integer(0),area=numeric(0),ck.positive=logical(0),tissue.type=character(0),nucleus.x=numeric(0),nucleus.y=numeric(0))
    delaunay.edges=data.table(cell.ID1=integer(0),cell.ID2=integer(0),length=numeric(0),valid=logical(0))
    voronoi.cells=data.table(cell.ID=integer(0),x=numeric(0),y=numeric(0))
    filename=paste0(outputdir,"/tissue_segmentation.RData")
    cat(paste0("[",format(Sys.time()),"] "),"Saving results in",filename,"\n")
    save(voronoi.cells.summary,delaunay.edges,voronoi.cells,metadata.channel.thresholding,threshold.ck.positive,max.cell.radius.micron,max.connectivity.distance.micron,small.component.size.threshold,large.component.size.threshold,score.type.ck,input.ck,channel.dapi,channel.autofluorescence,unmixed.images.max.values,input.image,input.dapi,input.autofluorescence,metadata,image.info,cwd,blur.sigma,blur.sigma.nosignal,threshold.dapi.positive,watershed.low.dapi,extended.nucleus.radius.pixel,sharpness.diameter.pixel,sharpness.low.threshold,sharpness.high.threshold,clip.region,convert.tile.to.slide.position.x,convert.slide.to.tile.position.x,convert.tile.to.slide.position.y,convert.slide.to.tile.position.y,convert.tile.to.slide.length,convert.slide.to.tile.length,convert.tile.to.slide.area,convert.slide.to.tile.area,convert.tile.to.image.position.x,convert.tile.to.image.position.y,convert.image.to.tile.position.x,convert.image.to.tile.position.y,convert.tile.to.image.length,convert.image.to.tile.length,convert.tile.to.image.area,convert.image.to.tile.area,convert.image.to.slide.position.x,convert.slide.to.image.position.x,convert.image.to.slide.position.y,convert.slide.to.image.position.y,convert.image.to.slide.length,convert.slide.to.image.length,convert.image.to.slide.area,convert.slide.to.image.area,unmixing.parameters,unmix_images,plot_image,get.contour.points,draw.contour.points,file=filename)
    

    clean()
    cat(paste0("[",format(Sys.time()),"] "),"Done\n")
    quit()

}

##to be used later
max.data.binned=unlist(data.binned[,lapply(.SD,max),.SDcols=patterns("channel_")])
rm(data.binned)
gc()

############################################
## Evaluate score
############################################

##check that cell.ID correspond to row index.
if(!all(nucleusFeatures.image[["shape"]][,"cell.ID"]==seq_along(nucleusFeatures.image[["shape"]][,"cell.ID"])))
  stop("problem with cell.ID")

data.score=nucleusFeatures.image[["shape"]][,c("cell.ID","nucleus.x","nucleus.y"),drop=FALSE]
for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    score.type=metadata.channel.thresholding[f,"score.type"]
    ##split score.type into summary statistic and region
    score.type.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",score.type)
    score.type.statistic=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",score.type)
    ##check
    if(!score.type.region%in%c("nucleus","extended.nucleus","around.nucleus"))
        stop("Invalid score type",score.type,". Accepted regions: nucleus, extended.nucleus or around.nucleus")
    if(!score.type.statistic%in%c("mean","median","q001","q005","q025","q075","q095","q099","circular.q005","circular.q010","circular.q025","circular.q050"))
        stop("Invalid score type ",score.type,". Accepted summary statistics: mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050")
    if(score.type.statistic=="median")score.type.statistic="q050"

    if(score.type.region=="nucleus")
    {
        data.score=cbind(data.score,nucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="extended.nucleus")
    {
        data.score=cbind(data.score,extendedNucleusFeatures.image[[f]][,score.type.statistic])
    }
    if(score.type.region=="around.nucleus")
    {
        data.score=cbind(data.score,aroundNucleusFeatures.image[[f]][,score.type.statistic])
    }
}
colnames(data.score)=c("cell.ID","nucleus.x","nucleus.y",rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])


cat(paste0("[",format(Sys.time()),"] "),ck.channel.name,"channel score distribution (quantiles=0%,1%,10%,50%,90%,99%,100%):",paste(quantile(data.score[,input.ck],probs=c(0,0.01,0.1,0.5,0.9,0.99,1)),collapse=","),"\n")

set.seed(12734)
rm(nucleusFeatures.image)
rm(extendedNucleusFeatures.image)
rm(aroundNucleusFeatures.image)
gc()

############################################
## Tissue (delaunay triangulation/voronoi tesselation)
############################################

cat(paste0("[",format(Sys.time()),"] "),"Tissue segmentation using",ck.channel.name,"score.type",score.type.ck,"and threshold",threshold.ck.positive,"\n")

max.cell.radius.pixel=convert.slide.to.tile.length(max.cell.radius.micron,image.info)
max.connectivity.distance.pixel=convert.slide.to.tile.length(max.connectivity.distance.micron,image.info)

set.seed(12734)

##check that cell.ID correspond to row index => delaunay.points and data.score row index correspond to cell.ID
if(!all(data.score[,c("cell.ID")]==1:nrow(data.score)))
{
    stop("problem with cell.ID")
}
delaunay.points=data.score[,c("nucleus.x","nucleus.y"),drop=FALSE]


##add dummy boundary points on a circle enclosing all cells centers (to avoid infinite voronoi cells)
cat(paste0("[",format(Sys.time()),"] "),"adding dummy external points\n")
xmin=min(delaunay.points[,"nucleus.x"])
xmax=max(delaunay.points[,"nucleus.x"])
ymin=min(delaunay.points[,"nucleus.y"])
ymax=max(delaunay.points[,"nucleus.y"])
cx=(xmin+xmax)/2
cy=(ymin+ymax)/2
r=1.2*sqrt((xmax-xmin)**2+(ymax-ymin)**2)/2+max(max.connectivity.distance.pixel,2*max.cell.radius.pixel)
ndummy=16
external.points.ids=nrow(delaunay.points)+1:ndummy
set.seed(12734)
for(i in 1:ndummy)
{
    t=2*pi*(i-1)/ndummy
    x=cx+runif(1,min=1,max=1.001)*r*cos(t) ##randomize radius to avoid co-circularity of dummy points
    y=cy+runif(1,min=1,max=1.001)*r*sin(t) 
    delaunay.points=rbind(delaunay.points,
                          c(nucleus.x=x,nucleus.y=y))
}

cat(paste0("[",format(Sys.time()),"] "),"delaunay triangulation\n")
delaunay.triangles=data.table(geometry::delaunayn(delaunay.points[,c("nucleus.x","nucleus.y")]))
setnames(delaunay.triangles,c("cell.ID1","cell.ID2","cell.ID3"))
##add id
delaunay.triangles[,tri.ID:=1:nrow(delaunay.triangles)]
##add circumcenters (https://www.ics.uci.edu/~eppstein/junkyard/circumcenter.html)
delaunay.triangles[,xba:=delaunay.points[,"nucleus.x"][cell.ID2]-delaunay.points[,"nucleus.x"][cell.ID1]]
delaunay.triangles[,yba:=delaunay.points[,"nucleus.y"][cell.ID2]-delaunay.points[,"nucleus.y"][cell.ID1]]
delaunay.triangles[,xca:=delaunay.points[,"nucleus.x"][cell.ID3]-delaunay.points[,"nucleus.x"][cell.ID1]]
delaunay.triangles[,yca:=delaunay.points[,"nucleus.y"][cell.ID3]-delaunay.points[,"nucleus.y"][cell.ID1]]
delaunay.triangles[,ba:=xba * xba + yba * yba]
delaunay.triangles[,ca:=xca * xca + yca * yca]
delaunay.triangles[,d:=0.5 / (xba * yca - yba * xca)]
delaunay.triangles[,circumcircle.x:=delaunay.points[,"nucleus.x"][cell.ID1]+(yca * ba - yba * ca) * d]
delaunay.triangles[,circumcircle.y:=delaunay.points[,"nucleus.y"][cell.ID1]+(xba * ca - xca * ba) * d]
delaunay.triangles[,xba:=NULL]
delaunay.triangles[,yba:=NULL]
delaunay.triangles[,xca:=NULL]
delaunay.triangles[,yca:=NULL]
delaunay.triangles[,ba:=NULL]
delaunay.triangles[,ca:=NULL]
delaunay.triangles[,d:=NULL]

setkey(delaunay.triangles,tri.ID)
##check tri.ID corresponds to row index
if(!delaunay.triangles[,all(tri.ID==.I)])
  stop("problem with tri.ID")

## delaunay edges 
cat(paste0("[",format(Sys.time()),"] "),"extracting delaunay edges\n")
delaunay.edges=unique(rbind(
    unique(delaunay.triangles[,.(cell.ID1=pmin(cell.ID1,cell.ID2),cell.ID2=pmax(cell.ID1,cell.ID2))]),
    unique(delaunay.triangles[,.(cell.ID1=pmin(cell.ID2,cell.ID3),cell.ID2=pmax(cell.ID2,cell.ID3))]),
    unique(delaunay.triangles[,.(cell.ID1=pmin(cell.ID3,cell.ID1),cell.ID2=pmax(cell.ID3,cell.ID1))])))
delaunay.edges[,length:=sqrt((delaunay.points[,"nucleus.x"][delaunay.edges[,cell.ID1]]-delaunay.points[,"nucleus.x"][delaunay.edges[,cell.ID2]])**2+
                             (delaunay.points[,"nucleus.y"][delaunay.edges[,cell.ID1]]-delaunay.points[,"nucleus.y"][delaunay.edges[,cell.ID2]])**2)]
delaunay.edges[,valid:=length<=max.connectivity.distance.pixel]



##ignore dummy external points (=> all remaining points are internal)
cat(paste0("[",format(Sys.time()),"] "),"voronoi cells\n")
voronoi.cells=melt(delaunay.triangles[,.(cell.ID1,cell.ID2,cell.ID3,tri.ID)],id.var="tri.ID",value.name="cell.ID")[!cell.ID%in%external.points.ids,.(cell.ID,tri.ID)]

setkey(voronoi.cells,tri.ID)
##add angle circumcircle-centerpoint
voronoi.cells[,angle:=(atan2(delaunay.triangles[voronoi.cells,circumcircle.y]-delaunay.points[,"nucleus.y"][cell.ID],delaunay.triangles[voronoi.cells,circumcircle.x]-delaunay.points[,"nucleus.x"][cell.ID]))%%(2*pi)]
##setorder
setorder(voronoi.cells,cell.ID,angle)

##add x,y coordinates to voronoi.cells
voronoi.cells[,x0:=delaunay.points[,"nucleus.x"][cell.ID]]
voronoi.cells[,y0:=delaunay.points[,"nucleus.y"][cell.ID]]
voronoi.cells[,x:=delaunay.triangles[voronoi.cells[,tri.ID],circumcircle.x]]
voronoi.cells[,y:=delaunay.triangles[voronoi.cells[,tri.ID],circumcircle.y]]

## ################
## shrink voronoi cells to be within circle of radius max.cell.radius.pixel centered on nucleus

cat(paste0("[",format(Sys.time()),"] "),"shrinking voronoi cells\n")

##find intersection points between voronoi segments and circle of radius max.cell.radius.pixel centered on (x0,y0)
##circle: points (x,y) such that (x-x0)**2+(y-y0)**2=r**2
##segment (x1,y1)-(x2,y2): points (x,y) such that  x=x1+t*(x2-x1); y=y1+t*(y2-y1) for all 0<=t<=1
##intersection: find t such that
## a*t**2+b*t+c==0
## with
## a=((x2-x1)**2+(y2-y1)**2)
## b=2*((x1-x0)*(x2-x1)+(y1-y0)*(y2-y1))
## c=(x1-x0)**2+(y1-y0)**2-max.cell.radius.pixel**2
##stable solution:
## delta=b**2-4*a*c
## if delta<0 => no solution (i.e. no intersection, line outside of circle)
## if delta>=0 and b>=0: t1=(-b-sqrt(delta))/(2*a); t2=(2*c)/(-b-sqrt(delta)) => ignore t1,t2 <0 or >1. Remaining t's are intersections: (x,y)=(x1+t*(x2-x1),y1+t*(y2-y1))
## if delta>=0 and b<0: t1=(2*c)/(-b+sqrt(delta)); t2=(-b+sqrt(delta))/(2*a) => ignore t1,t2 <0 or >1. Remaining t's are intersections: (x,y)=(x1+t*(x2-x1),y1+t*(y2-y1))

## for each voronoi cell (i.e. cell.ID), duplicate first point (i.e. tri.ID) to close the cycle
voronoi.segments=rbind(voronoi.cells[,.(cell.ID,tri.ID,angle)],
                       voronoi.cells[,.(tri.ID=tri.ID[which.min(angle)],angle=min(angle)+2*pi),by=cell.ID])
setorder(voronoi.segments,cell.ID,angle)
##extract segments (tri.ID1,tri.ID2)
voronoi.segments=voronoi.segments[,.(tri.ID1=tri.ID,tri.ID2=data.table::shift(tri.ID,type="lead")),by=cell.ID][!is.na(tri.ID2)]

##add x,y coordinates 
voronoi.segments[,x0:=delaunay.points[,"nucleus.x"][cell.ID]]
voronoi.segments[,y0:=delaunay.points[,"nucleus.y"][cell.ID]]
voronoi.segments[,x1:=delaunay.triangles[voronoi.segments[,tri.ID1],circumcircle.x]]
voronoi.segments[,y1:=delaunay.triangles[voronoi.segments[,tri.ID1],circumcircle.y]]
voronoi.segments[,x2:=delaunay.triangles[voronoi.segments[,tri.ID2],circumcircle.x]]
voronoi.segments[,y2:=delaunay.triangles[voronoi.segments[,tri.ID2],circumcircle.y]]
##eval intersection between segment and circle of radius max.cell.radius.pixel centered on (x0,y0)
voronoi.segments[,a:=((x2-x1)**2+(y2-y1)**2)]
voronoi.segments[,b:=2*((x1-x0)*(x2-x1)+(y1-y0)*(y2-y1))]
voronoi.segments[,c:=(x1-x0)**2+(y1-y0)**2-max.cell.radius.pixel**2]
voronoi.segments[,delta:=b**2-4*a*c]
voronoi.segments[delta>=0&b>=0,t1:=(-b-sqrt(delta))/(2*a)]
voronoi.segments[delta>=0&b>=0,t2:=(2*c)/(-b-sqrt(delta))]
voronoi.segments[delta>=0&b<0,t1:=(2*c)/(-b+sqrt(delta))]
voronoi.segments[delta>=0&b<0,t2:=(-b+sqrt(delta))/(2*a)]    
voronoi.segments[t1<0|t1>1,t1:=NA]
voronoi.segments[t2<0|t2>1,t2:=NA]
##for segments completely outside if circles (i.e. line does not intersect circle, delta<0): add middle point i.e. t1=0.5
voronoi.segments[delta<0,t1:=0.5]
##remove columns
voronoi.segments[,a:=NULL]
voronoi.segments[,b:=NULL]
voronoi.segments[,c:=NULL]
voronoi.segments[,delta:=NULL]   
##ignore duplicate intersection points (t1==t2)
voronoi.segments[is.finite(t1)&is.finite(t2)&abs(t2-t1)<1e-6,t2:=NA]    
##keep only problematic segments: segments outside of circle (i.e. line does not intersect circle, delta<0, i.e. t1=0.5) or segment intersect circle (t1 or t2 is finite)
voronoi.segments=voronoi.segments[is.finite(t1)|is.finite(t2)]    
##add first intersection points (xi,yi) (with tri.ID=NA)
voronoi.cells=rbind(voronoi.cells,
                    voronoi.segments[is.finite(t1),.(cell.ID,tri.ID=NA,xi=x1+t1*(x2-x1),yi=y1+t1*(y2-y1),x0,y0)][,.(cell.ID,tri.ID,angle=atan2(yi-y0,xi-x0)%%(2*pi),x0,y0,x=xi,y=yi)])    
##add second intersection points (xi,yi) (with tri.ID=NA)
voronoi.cells=rbind(voronoi.cells,
                    voronoi.segments[is.finite(t2),.(cell.ID,tri.ID=NA,xi=x1+t2*(x2-x1),yi=y1+t2*(y2-y1),x0,y0)][,.(cell.ID,tri.ID,angle=atan2(yi-y0,xi-x0)%%(2*pi),x0,y0,x=xi,y=yi)])
setorder(voronoi.cells,cell.ID,angle)
rm(voronoi.segments)

##shrink voronoi cells: move points outside of circle on circle
voronoi.cells[,d:=sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0))]
voronoi.cells[,x:=x0+pmin(max.cell.radius.pixel,d)*(x-x0)/d]
voronoi.cells[,y:=y0+pmin(max.cell.radius.pixel,d)*(y-y0)/d]
voronoi.cells[,d:=NULL]


## ############
## voronoi cells summary (area)
cat(paste0("[",format(Sys.time()),"] "),"voronoi cells area\n")
##duplicate first point to close the cycle
voronoi.segments=rbind(voronoi.cells[,.(cell.ID,x0,y0,x,y,angle)],
                       voronoi.cells[,.(x=x[which.min(angle)],y=y[which.min(angle)],angle=min(angle)+2*pi),by=.(cell.ID,x0,y0)])
setorder(voronoi.segments,cell.ID,angle)
##extract segments
voronoi.segments=voronoi.segments[,.(dx1=x-x0,dy1=y-y0,dx2=data.table::shift(x,type="lead")-x0,dy2=data.table::shift(y,type="lead")-y0),by=.(cell.ID,x0,y0)][!is.na(dx2)]
##area of each triangle formed by (x0,y0) and the segment
voronoi.segments[,area:=(dx1*dy2-dy1*dx2)/2]
voronoi.cells.summary=voronoi.segments[,.(area=sum(area)),by=cell.ID]
setorder(voronoi.cells.summary,cell.ID)
setkey(voronoi.cells.summary,cell.ID)
##check cell.ID corresponds to row index
if(!voronoi.cells.summary[,all(cell.ID==.I)])
  stop("problem with cell.ID")
rm(voronoi.segments)
gc()

cat(paste0("[",format(Sys.time()),"] "),"initial tissue segmentation\n")
if(tumor_marker_present)
{
    ##ck positivity
    voronoi.cells.summary[,ck.positive:=data.score[cell.ID,input.ck]>threshold.ck.positive]
    ##initial tissue.type based on ck.positivity
    voronoi.cells.summary[,tissue.type:=ifelse(ck.positive,"tumor","stroma")]
}
if(tumor_marker_present==FALSE)
{
    ##no tumor marker channel
    ##ck positivity
    voronoi.cells.summary[,ck.positive:=FALSE]
    ##initial tissue.type based on ck.positivity
    voronoi.cells.summary[,tissue.type:="other"]
}





## ############
## igraph

cat(paste0("[",format(Sys.time()),"] "),"creating delaunay graph for tissue segmentation\n")
##keep all edges
e=delaunay.edges[cell.ID1%in%voronoi.cells.summary$cell.ID&cell.ID2%in%voronoi.cells.summary$cell.ID]
v=voronoi.cells.summary[cell.ID%in%voronoi.cells.summary$cell.ID,.(cell.ID=cell.ID,ck.positive,tissue.type)]
g=graph_from_data_frame(e, directed = FALSE, vertices = v)

##keep only valid edges (i.e. with length<=max.connectivity.distance.pixel) connecting same tissue.type and evaluate connected components (i.e. groups of connected cells with same tissue.type)
comp=components(subgraph.edges(g,E(g)[E(g)$valid&head_of(g,E(g))$tissue.type==tail_of(g,E(g))$tissue.type], delete.vertices = FALSE))

##build graph of connected components (only valid edges, i.e. with length<=max.connectivity.distance.pixel)
v.comp=unique(v[,.(comp.ID=comp$membership[as.character(cell.ID)],tissue.type,component.size=comp$csize[comp$membership[as.character(cell.ID)]])])[order(comp.ID)]
e.comp=unique(e[valid==TRUE,.(comp.ID1=comp$membership[as.character(cell.ID1)],comp.ID2=comp$membership[as.character(cell.ID2)])][comp.ID1!=comp.ID2])
g.comp=graph_from_data_frame(e.comp, directed = FALSE, vertices = v.comp)

##keep only edges connecting at least one "big component" (>large.component.size.threshold)
g.comp2=subgraph.edges(g.comp,E(g.comp)[head_of(g.comp,E(g.comp))$component.size>large.component.size.threshold|tail_of(g.comp,E(g.comp))$component.size>large.component.size.threshold], delete.vertices = FALSE)    
##select small (<=small.component.size.threshold) components connected to at least another component (big component since edges connect at least one big component)
small.components=V(g.comp2)[degree(g.comp2)>0&V(g.comp2)$component.size<=small.component.size.threshold]
rm(g.comp2)
##get corresponding cell.ID
small.components.cell.ID=as.integer(names(comp$membership)[comp$membership%in%as.integer(small.components$name)])
##invert tissue.type in g
new.tissue.type=c(tumor="stroma",stroma="tumor")
V(g)[V(g)$name%in%small.components.cell.ID]$tissue.type=new.tissue.type[V(g)[V(g)$name%in%small.components.cell.ID]$tissue.type]

##select ISOLATED small (<=small.component.size.threshold) components 
isolated.small.components=V(g.comp)[degree(g.comp)==0&V(g.comp)$component.size<=small.component.size.threshold]
rm(g.comp)
rm(e.comp)
rm(v.comp)
##get corresponding cell.ID
isolated.small.components.cell.ID=as.integer(names(comp$membership)[comp$membership%in%as.integer(isolated.small.components$name)])
##set tissue.type to "other"
V(g)[V(g)$name%in%isolated.small.components.cell.ID]$tissue.type="other"



##update tissue type to voronoi.cells.summary
voronoi.cells.summary[as.integer(V(g)$name),tissue.type:=V(g)$tissue.type]

##add nucleus position
voronoi.cells.summary[,nucleus.x:=delaunay.points[cell.ID,"nucleus.x"]]
voronoi.cells.summary[,nucleus.y:=delaunay.points[cell.ID,"nucleus.y"]]

rm(delaunay.points)
rm(small.components)
rm(small.components.cell.ID)
rm(isolated.small.components)
rm(isolated.small.components.cell.ID)
rm(comp)
rm(g)
rm(e)
rm(v)

############################################
##save
############################################

##keep only delaunay.edge between non-dummy points
delaunay.edges=delaunay.edges[cell.ID1%in%voronoi.cells.summary$cell.ID&cell.ID2%in%voronoi.cells.summary$cell.ID]
##rename columns
voronoi.cells=voronoi.cells[,.(cell.ID,x,y)]

##save RData
filename=paste0(outputdir,"/tissue_segmentation.RData")
cat(paste0("[",format(Sys.time()),"] "),"Saving results in",filename,"\n")
save(voronoi.cells.summary,delaunay.edges,voronoi.cells,metadata.channel.thresholding,threshold.ck.positive,max.cell.radius.micron,max.connectivity.distance.micron,small.component.size.threshold,large.component.size.threshold,score.type.ck,input.ck,channel.dapi,channel.autofluorescence,unmixed.images.max.values,input.image,input.dapi,input.autofluorescence,metadata,image.info,cwd,blur.sigma,blur.sigma.nosignal,threshold.dapi.positive,watershed.low.dapi,extended.nucleus.radius.pixel,sharpness.diameter.pixel,sharpness.low.threshold,sharpness.high.threshold,clip.region,convert.tile.to.slide.position.x,convert.slide.to.tile.position.x,convert.tile.to.slide.position.y,convert.slide.to.tile.position.y,convert.tile.to.slide.length,convert.slide.to.tile.length,convert.tile.to.slide.area,convert.slide.to.tile.area,convert.tile.to.image.position.x,convert.tile.to.image.position.y,convert.image.to.tile.position.x,convert.image.to.tile.position.y,convert.tile.to.image.length,convert.image.to.tile.length,convert.tile.to.image.area,convert.image.to.tile.area,convert.image.to.slide.position.x,convert.slide.to.image.position.x,convert.image.to.slide.position.y,convert.slide.to.image.position.y,convert.image.to.slide.length,convert.slide.to.image.length,convert.image.to.slide.area,convert.slide.to.image.area,unmixing.parameters,unmix_images,plot_image,get.contour.points,draw.contour.points,file=filename)




clean()
cat(paste0("[",format(Sys.time()),"] "),"Done\n")
