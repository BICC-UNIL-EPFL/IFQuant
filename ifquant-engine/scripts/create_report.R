#!/usr/bin/env Rscript

## Copyright (C) 2022 Julien Dorier and UNIL (University of Lausanne).
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <https://www.gnu.org/licenses/>.

##########################################
#parse command line options
##########################################
          
args=commandArgs(trailingOnly = TRUE)

library(optparse)

usage="
  %prog [options] merge_cells_RData tissue_segmentation_RData"

description="
Positional arguments:
\tmerge_cells_RData
\t\tRData file generated by merge_cells.R.
\ttissue_segmentation_RData
\t\tRData file generated by tissue_segmentation.R."

epilogue=""

#default=NA => mandatory, default=NULL => optional.
option_list=list( 
    make_option(c("--nprocesses"), type="integer", default=1,metavar="N",
                help="Max number of threads to use (only for data.table) [default %default]."),
    make_option(c("--thresholds"), type="character", default=NULL,metavar="FILENAME",
                help="File with channel thresholding information.
\t\tTab separated file with header in the first row and at least 4 columns:
\t\t * channel: channel number (0, 1, 2, ...).
\t\t * name: channel name (DAPI, CD15,... must correspond to metadata).
\t\t * score.type: score type
\t\t    should have the form <summary_statistic>.<region> with
\t\t    <summary_statistic>=mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050
\t\t     where q<n> is the n-th percentile and circular.q<n> is the n-th percentile of max in all directions.
\t\t    <region>=nucleus, extended.nucleus or around.nucleus
\t\t    e.g. mean.nucleus, median.extended.nucleus, q001.nucleus, q095.around.nucleus, circular.q010.around.nucleus
\t\t * threshold: numeric threshold. A cell is \"positive\" for a channel if its score is above threshold.
\t\tIf not specified: use thresholds saved in tissue_segmentation_RData.
\t\tWARNING: threshold for <tumor_marker> (e.g. CK) must be identical to the threshold used for tissue segmentation and stored in tissue_segmentation_RData."),
    make_option(c("--phenotypes"), type="character", default=NULL,metavar="FILENAME",
                help="File with phenotypes definition.
\t\tTab separated file with one phenotype per row (header in the first row) and the following columns:
\t\t * label: phenotype label (e.g. CD15-CD163-CD11c-CD20-CD3-, macrophage,...)
\t\t * one column per channel (except channel with nucleus staining, e.g. DAPI, and autofluorescence) with column name corresponding to channel_<number>,
\t\t   with <number> corresponding to column channel in the  panel metadata (e.g. channel_2, channel_3,..),
\t\t   and entries -, + or * corresponding to negative, positive or ignored.
\t\t   e.g.
\t\t    label                       channel_1  channel_2  channel_3  channel_4  channel_5  channel_6
\t\t    CD15-CD163-CD11c-CD20-CD3-  -          *          -          -          -          -
\t\t    CD15+CD163+CD11c-CD20-CD3-  +          *          +          -          -          -
\t\t    CD15+CD163-CD11c+CD20-CD3-  +          *          -          +          -          -
\t\t    CD15+CD163-CD11c-CD20+CD3-  +          *          -          -          +          -
\t\tIf not specified: use a dummy list of phenotypes."),
    make_option(c("--sample-info"), type="character", default=NULL,metavar="FILENAME",
                help="File with sample informations.
\t\tTab separated file WITHOUT header in the first row and two columns (property name and value).
\t\tThis file will be used as is in the first page of the report.
\t\tIf not specified: info will be extracted from image name."),
    make_option(c("--channel-normalization"), type="character", default=NULL,metavar="FILENAME",
                help="File with single stained image distribution.
\t\tUsed for channel normalization when plotting images."),
    make_option(c("--input-image"), type="character", default=NULL,metavar="FILENAME",
                help="qptiff image. If not specified, use filename stored in merge_cells_RData,"),
    make_option(c("--excluded-regions"), type="character", default=NULL,metavar="FILENAME",
                help="File with excluded regions (closed polygons).
\t\tComma separated format with header in the first row and 3 columns: id, x and y.
\t\tThis file can contain multiple polygons, each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point.
\t\tAll cells with center inside an excluded region will be ignored."),
    make_option(c("--ROI"), type="character", default=NULL,metavar="FILENAME",
                help="File with regions of interest (closed polygons).
\t\tComma separated format with header in the first row, 3 mandatory columns and 1 optional column: id, x, y and label (optional).
\t\tThis file can contain multiple polygons (ROI), each with a different id.
\t\tPolygons are assumed to be closed, i.e. last point will be connected to first point."),
    make_option(c("--other-tissue"), action="store_true", default=FALSE,
                help="Also consider cells with \"other\" tissue type (ignored by default if there is a tumor marker)."),
    make_option(c("--output-tables"), action="store_true", default=FALSE,
                help="Export xlsx and tsv tables."),
    make_option(c("--rmarkdown"), type="character", default=NULL,metavar="FILENAME",
                help="rmarkdown report file to render.
\t\tIf not specified, search for report.rmd in the directory containing this script."),
    make_option(c("--automatic-thresholds"), type="character", default=NA,metavar="FILENAME",
                help="File with channel thresholding information generated by automatic_channel_thresholding.R [mandatory].
\t\tSame format as --thresholds. Only used to check if automatic <tumor_marker> threshold was used."),
    make_option(c("--automatic-thresholds-status"), type="character", default=NA,metavar="FILENAME",
                help="File with automatic channel thresholding status generated by automatic_channel_thresholding.R [mandatory].
\t\tTab separated file with header in the first row and 3 columns:
\t\t * channel: channel number (0, 1, 2, ...)
\t\t * name: channel name (DAPI, CD15,... must correspond to metadata)
\t\t * status: NOT_DONE, SUCCESS, FAILED, WARNING."),
    make_option(c("--TLS"), type="character", default=NULL,metavar="FILENAME",
                help="RData file generated by find_patches.R (only used with --output-tables).
\t\tAdd a column TLS.ID to cells_properties.tsv.gz."),
    make_option(c("--output"), type="character", default=NA,metavar="DIRNAME",
                help="Output directory [mandatory].")
)


opt=parse_args(OptionParser(option_list=option_list,
                            usage=usage,
                            description=description,
                            epilogue=epilogue
                            ),positional_arguments=2,args=args)

##check all options are set, and print them
for(o in option_list)
{
    n=slot(o,"dest")
    f=c(slot(o,"short_flag"),slot(o,"long_flag"))
    f=paste(f[!is.na(f)],sep=",")
    if(!is.null(opt$options[[n]])) ##Default NULL => optional.
    {
        if(is.na(opt$options[[n]])) ##Default NA => mandatory
            stop("option ",f," is mandatory")
        ##check type
        if(typeof(opt$options[[n]])!=slot(o,"type"))
            stop("option ",f," must be ",slot(o,"type"))
        ##print
        if(slot(o,"action")!="store_true")
            cat(slot(o,"long_flag"),"=",opt$options[[n]],"\n",sep="")
        if(slot(o,"action")=="store_true"&&opt$options[[n]]==TRUE)
            cat(slot(o,"long_flag"),"\n",sep="")
    }
}
cat("positional arguments: ",paste(opt$args,collapse=" "),"\n",sep="")

nprocesses=opt$options[["nprocesses"]]
input.thresholding=opt$options[["thresholds"]]
input.phenotypes=opt$options[["phenotypes"]]
input.sample.info=opt$options[["sample-info"]]
input.channel.normalization=opt$options[["channel-normalization"]]
input.image.param=opt$options[["input-image"]]
input.excluded.regions=opt$options[["excluded-regions"]]
input.ROI=opt$options[["ROI"]]
flag_other_tissue=opt$options[["other-tissue"]]
flag_tables=opt$options[["output-tables"]]
input.rmarkdown=opt$options[["rmarkdown"]]
input.automatic.thresholding=opt$options[["automatic-thresholds"]]
input.automatic.thresholding.status=opt$options[["automatic-thresholds-status"]]
input.TLS=opt$options[["TLS"]]
outputdir=opt$options[["output"]]


##check
if(!(is.finite(nprocesses)&nprocesses>0))
{
    stop("--nprocesses must be a positive integer")
}
if(is.null(input.rmarkdown))
{
    ##search for script directory
    initial.options <- commandArgs(trailingOnly = FALSE)
    script.path <- sub("--file=", "", initial.options[grep("--file=", initial.options)])
    script.path <- dirname(script.path)
    input.rmarkdown=paste0(script.path,"/report.rmd")
    if(!file.exists(input.rmarkdown))
    {
            stop(input.rmarkdown," does not exist. Please use option --rmarkdown=FILENAME.")
    }
    cat("using --rmarkdown=",input.rmarkdown,"\n",sep="")
       
}

##positional arguments
input_merge_cells.RData=opt$args[1]
input_tissue_segmentation.RData=opt$args[2]


set.seed(12734)

library(R.utils)  #for gzip
if(flag_tables)library(writexl)
library(data.table) 
library(viridis) #color palettes
library(EBImage)
library(sp) #point.in.polygon
library(RColorBrewer)
library(ggplot2)
library(RANN)
library(polyclip) ##polysimplify
library(RTriangle) ##triangulate
options(scipen=13)

#nb threads for data.table
setDTthreads(nprocesses)

##temporary directory (for figures)
figdir="figures_tmp/"
tmpdir=paste0(outputdir,"/",figdir)
dir.create(tmpdir,showWarnings=FALSE,recursive=TRUE)
tmpdir=normalizePath(tmpdir)

##temporary directory cleaning
clean=function(){
    cat(paste0("[",format(Sys.time()),"] "),"removing",tmpdir,"\n")
    unlink(tmpdir, recursive=TRUE)
}
##erase temporary directory on error    
if(!interactive())
    options(error=function(){clean();quit(status = 1)})

##colors for cell density plots
colors.density=c("#F5F5F5","#F3F4ED","#EAF6CF","#D9F5BD","#C3F2B0","#A6EFA7","#82EAA2","#4EE4A1","#00DDA3","#00D4A7","#00CAAC","#00BBAF","#00ACAF","#009BAB","#008AA5","#00799D","#006792","#005485","#034278","#1D2F6A","#26185F")

if(flag_other_tissue==FALSE)
    tissue.type.list=c("stroma","tumor")
if(flag_other_tissue)
    tissue.type.list=c("stroma","tumor","other")

############################################
##functions
############################################

##replace all non-allowed characters by "_"
##forbidden: a pattern (used in gsub)
##replace_by: characted to use for replacement
str_sanitize_path=function(x,forbidden="[^a-zA-Z0-9_-]",replace_by="_"){
    x=gsub(paste0(forbidden,"+"),replace_by,x)
    return(x)
}

##escape special characters (latex)
##function taken from knitr::escape_latex (https://cran.r-project.org/web/packages/knitr/index.html)
## escape special LaTeX characters
str_sanitize_latex=function(x){
  x = gsub("\\\\", "\\\\textbackslash", x)
  x = gsub("([_$#%&{}])", "\\\\\\1", x)
  x = gsub("\\\\textbackslash", "\\\\textbackslash{}", x)
  x = gsub("~", "\\\\textasciitilde{}", x)
  x = gsub("\\^", "\\\\textasciicircum{}", x)
  return(x)
}

##Return the area of the region defined by a set of polygons  (each polygon corresponding to a regions.of.interest$id).
##  Each polygon can have self intersection, and the interior of the polygon is defined using the even-odd rule used by point.in.polygon (which is used everywhere in the code to test the inclusion of points inside the regions)
##  With multiple polygons, the region is defined as the union of all polygons.
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
get_region_area=function(roi.label.idx){

    ##to reduce risks of problems with triangulate() we add noise to the positions. We allow up to 5 trials before stopping
    noise=0
    for(i in 1:5)
    {
        if(i>1)noise=1e-4
        area = tryCatch({
            if(length(roi.label.idx)==1&&roi.label.idx==-1)
            {
                ##"Tumor tissue" only
                tumor.label.idx=match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels)
                roi.ids=unlist(regions.of.interest.ids[tumor.label.idx])
                p=lapply(roi.ids,function(roi.id){
                    ##add noise to reduce risks of problems with triangulate()
                    list(x=regions.of.interest[id==roi.id,x+runif(.N,min=-noise,max=noise)],y=regions.of.interest[id==roi.id,y+runif(.N,min=-noise,max=noise)])
                })
                for(roi.label in tumor_tissue_only.ROI.toremove)
                {
                    if(roi.label%in%regions.of.interest.labels)
                    {
                        tmp.label.idx=match(roi.label,regions.of.interest.labels)
                        roi.ids=unlist(regions.of.interest.ids[tmp.label.idx])
                        for(roi.id in roi.ids)
                        {
                            p.toremove=list(x=regions.of.interest[id==roi.id,x+runif(.N,min=-noise,max=noise)],y=regions.of.interest[id==roi.id,y+runif(.N,min=-noise,max=noise)])
                            p=polyclip::polyclip(p,p.toremove,op="minus",fillA="evenodd",fillB="evenodd")
                        }
                    }
                }
                p=polyclip::polysimplify(p,filltype="evenodd")
            }
            else
            {
                roi.ids=unlist(regions.of.interest.ids[roi.label.idx])
                ##use polysimplify to find self intersections
                p=lapply(roi.ids,function(roi.id){
                    ##add noise to reduce risks of problems with triangulate()
                    list(x=regions.of.interest[id==roi.id,x+runif(.N,min=-noise,max=noise)],y=regions.of.interest[id==roi.id,y+runif(.N,min=-noise,max=noise)])
                })
                p=polyclip::polysimplify(p,filltype="evenodd")
            }
            if(length(p)==0)
                return(0)
            ##Generate a mesh (triangulation)
            ##initial list of vertices and edges
            v.orig=rbindlist(lapply(1:length(p),function(i){data.table(pID.orig=i,vID.orig=1:length(p[[i]]$x),x=p[[i]]$x,y=p[[i]]$y)}))
            e.orig=rbindlist(lapply(1:length(p),function(i){data.table(pID.orig1=i,vID.orig1=1:length(p[[i]]$x),pID.orig2=i,vID.orig2=((1:length(p[[i]]$x)))%%length(p[[i]]$x)+1)}))
            ##remove duplicate vertices
            v=unique(v.orig[,.(x,y)])
            ##new vID
            v[,vID:=1:.N]
            ##find mapping from (pID.orig,vID.orig) to vID
            map.orig.to.unique=v[v.orig,on=.(x,y)][,.(pID.orig,vID.orig,vID)]
            setkey(map.orig.to.unique,pID.orig,vID.orig)
            setkey(e.orig,pID.orig1,vID.orig1)
            e.orig[,vID1:=map.orig.to.unique[e.orig,vID]]
            setkey(e.orig,pID.orig2,vID.orig2)
            e.orig[,vID2:=map.orig.to.unique[e.orig,vID]]
            e=unique(e.orig[,.(vID1,vID2)])
            p=pslg(as.matrix(v[,.(x,y)]),S=as.matrix(e))
            tp=triangulate(p)
            ##extract list of triangles
            vertices=data.table(tp$P)
            setnames(vertices,c("x","y"))
            vertices[,vID:=1:.N]
            triangles=data.table(tp$T)
            setnames(triangles,c("vID1","vID2","vID3"))
            ##add points
            vertices[triangles,.(x1=x,y1=y),on=c("vID"="vID1")]
            triangles[,x1:=vertices[vID1,x]]
            triangles[,y1:=vertices[vID1,y]]
            triangles[,x2:=vertices[vID2,x]]
            triangles[,y2:=vertices[vID2,y]]
            triangles[,x3:=vertices[vID3,x]]
            triangles[,y3:=vertices[vID3,y]]
            ##check if center of the triangle is inside polygon
            triangles[,is.inside:=FALSE]
            if(length(roi.label.idx)==1&&roi.label.idx==-1)
            {
                ##"Tumor tissue" only
                tumor.label.idx=match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels)
                roi.ids=unlist(regions.of.interest.ids[tumor.label.idx])
                for(roi.id in roi.ids)
                {
                    triangles$is.inside=triangles$is.inside|(point.in.polygon(triangles[,(x1+x2+x3)/3],triangles[,(y1+y2+y3)/3],regions.of.interest[id==roi.id,x],regions.of.interest[id==roi.id,y])!=0)
                }
                for(roi.label in tumor_tissue_only.ROI.toremove)
                {
                    if(roi.label%in%regions.of.interest.labels)
                    {
                        tmp.label.idx=match(roi.label,regions.of.interest.labels)
                        roi.ids=unlist(regions.of.interest.ids[tmp.label.idx])
                        for(roi.id in roi.ids)
                        {
                            triangles$is.inside=triangles$is.inside&!(point.in.polygon(triangles[,(x1+x2+x3)/3],triangles[,(y1+y2+y3)/3],regions.of.interest[id==roi.id,x],regions.of.interest[id==roi.id,y])!=0)
                        }
                    }
                }
            }
            else
            {
                roi.ids=unlist(regions.of.interest.ids[roi.label.idx])
                for(roi.id in roi.ids)
                {
                    triangles$is.inside=triangles$is.inside|(point.in.polygon(triangles[,(x1+x2+x3)/3],triangles[,(y1+y2+y3)/3],regions.of.interest[id==roi.id,x],regions.of.interest[id==roi.id,y])!=0)
                }
            }
            ##area
            triangles[,area:=abs((x2-x1)*(y3-y1)-(y2-y1)*(x3-x1))/2]
            return(triangles[is.inside==TRUE,sum(area)])
        },
        error = function(e) {
            return(NA)
        })
        if(!is.na(area))
            break
    }
    if(is.na(area))
        stop("get_region_area failed.")
    return(area)
}

    

############################################
##load
############################################

cat(paste0("[",format(Sys.time()),"] "),"loading",input_merge_cells.RData,"\n")
load(input_merge_cells.RData)
image.info.tmp=image.info
metadata.tmp=metadata

cat(paste0("[",format(Sys.time()),"] "),"loading",input_tissue_segmentation.RData,"\n")
load(input_tissue_segmentation.RData)

##just in case we load older versions of input_merge_cells.RData and input_tissue_segmentation.RData without clip.region
if(!exists("clip.region"))
    clip.region=c(x.min=0,y.min=0,x.max=image.info$image.width.pixel,y.max=image.info$image.height.pixel)

tumor_marker_present=(length(input.ck)>0)

##simple check
if(!identical(image.info.tmp,image.info))
{
    stop("inconsistent image.info in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}
if(!identical(metadata.tmp,metadata))
{
    stop("inconsistent metadata in ",input_merge_cells.RData," and ",input_tissue_segmentation.RData)
}

if(!is.null(input.image.param))
    input.image=input.image.param

if(!is.null(input.thresholding))
{
    cat(paste0("[",format(Sys.time()),"] "),"loading",input.thresholding,"\n")
    metadata.channel.thresholding.tmp=read.table(input.thresholding,header=TRUE,stringsAsFactors=FALSE,sep="\t")
    metadata.channel.thresholding.tmp=metadata.channel.thresholding.tmp[order(metadata.channel.thresholding.tmp$channel),]
    rownames(metadata.channel.thresholding.tmp)=paste0("channel_",metadata.channel.thresholding.tmp$channel)
    ##check
    channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
    if(!all(metadata.channel.thresholding[channels,"channel"]==metadata.channel.thresholding.tmp[channels,"channel"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(metadata.channel.thresholding[channels,"name"]==metadata.channel.thresholding.tmp[channels,"name"]))
    {
        stop("Invalid",input.thresholding)
    }
    if(!all(c("score.type","threshold")%in%colnames(metadata.channel.thresholding.tmp)))
    {
        stop("Invalid",input.thresholding)
    }
    ##check identical CK threshold
    if(tumor_marker_present)
    {
        if(metadata.channel.thresholding[input.ck,"score.type"]!=metadata.channel.thresholding.tmp[input.ck,"score.type"]||abs(metadata.channel.thresholding[input.ck,"threshold"]-metadata.channel.thresholding.tmp[input.ck,"threshold"])>1e-8)
        {
            stop("Invalid",input.thresholding,". ",metadata[input.ck,"name"]," threshold must correspond to threshold used during tissue segmentation.")
        }
        if(abs(threshold.ck.positive-metadata.channel.thresholding.tmp[input.ck,"threshold"])>1e-8)
        {
            stop("Invalid",input.thresholding,". ",metadata[input.ck,"name"]," threshold must correspond to threshold used during tissue segmentation.")
        }
    }
    ##replace
    metadata.channel.thresholding=metadata.channel.thresholding.tmp
}

##automatic thresholding
cat(paste0("[",format(Sys.time()),"] "),"loading",input.automatic.thresholding,"\n")
metadata.automatic.channel.thresholding=read.table(input.automatic.thresholding,header=TRUE,stringsAsFactors=FALSE,sep="\t")
metadata.automatic.channel.thresholding=metadata.automatic.channel.thresholding[order(metadata.automatic.channel.thresholding$channel),]
rownames(metadata.automatic.channel.thresholding)=paste0("channel_",metadata.automatic.channel.thresholding$channel)
##check
channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
if(!all(metadata.channel.thresholding[channels,"channel"]==metadata.automatic.channel.thresholding[channels,"channel"]))
{
    stop("Invalid",input.automatic.thresholding)
}
if(!all(metadata.channel.thresholding[channels,"name"]==metadata.automatic.channel.thresholding[channels,"name"]))
{
    stop("Invalid",input.automatic.thresholding)
}
if(!all(c("score.type","threshold")%in%colnames(metadata.automatic.channel.thresholding)))
{
    stop("Invalid",input.automatic.thresholding)
}
##automatic thresholding status
status.metadata.automatic.channel.thresholding=read.table(input.automatic.thresholding.status,header=TRUE,stringsAsFactors=FALSE,sep="\t")
status.metadata.automatic.channel.thresholding=status.metadata.automatic.channel.thresholding[order(status.metadata.automatic.channel.thresholding$channel),]
rownames(status.metadata.automatic.channel.thresholding)=paste0("channel_",status.metadata.automatic.channel.thresholding$channel)
##check
channels=rownames(metadata.channel.thresholding[!metadata.channel.thresholding$channel%in%c(channel.dapi,channel.autofluorescence),])
if(!all(metadata.channel.thresholding[channels,"channel"]==status.metadata.automatic.channel.thresholding[channels,"channel"]))
{
    stop("Invalid",input.automatic.thresholding.status)
}
if(!all(metadata.channel.thresholding[channels,"name"]==status.metadata.automatic.channel.thresholding[channels,"name"]))
{
    stop("Invalid",input.automatic.thresholding.status)
}
##CK automatic thresholding
automatic.ck.thresholding.status=status.metadata.automatic.channel.thresholding[input.ck,"status"]
automatic.ck.thresholding.status=gsub("SUCCESS","Success",automatic.ck.thresholding.status)
automatic.ck.thresholding.status=gsub("WARNING","Warning",automatic.ck.thresholding.status)
automatic.ck.thresholding.status=gsub("FAILED","Failed",automatic.ck.thresholding.status)
automatic.ck.thresholding.status=gsub("NOT_DONE","Not done",automatic.ck.thresholding.status)
##check that automatic threshold was indeed used
if(tumor_marker_present&&(metadata.channel.thresholding[input.ck,"score.type"]!=metadata.automatic.channel.thresholding[input.ck,"score.type"]||abs(metadata.channel.thresholding[input.ck,"threshold"]-metadata.automatic.channel.thresholding[input.ck,"threshold"])>1e-8))
    automatic.ck.thresholding.status="Manually adjusted"


##add tissue.type
voronoi.cells[,tissue.type:=voronoi.cells.summary[voronoi.cells,tissue.type,on="cell.ID"]]


channel.normalization=rep(1,nrow(metadata))
names(channel.normalization)=rownames(metadata)
if(!is.null(input.channel.normalization))
{
    ##ignore autofluorescence when normalizing
    data.channel.normalization=read.csv(input.channel.normalization,stringsAsFactors=FALSE)
    channel.normalization=data.channel.normalization$mean
    names(channel.normalization)=data.channel.normalization$channel
    channel.normalization=channel.normalization/mean(channel.normalization[rownames(metadata)[metadata$channel!=channel.autofluorescence]])
    channel.normalization=channel.normalization[rownames(metadata)]
}


if(!is.null(input.sample.info))
{
    sample.info=data.frame(fread(input.sample.info,sep="\t",header=FALSE))
}
if(is.null(input.sample.info))
{
    
    sample.info=data.frame()
    sample.info=rbind(sample.info,data.frame(c1="sample_id",c2=basename(input.image)))
}

ck.channel.name=metadata[input.ck,"name"]
if(tumor_marker_present==FALSE)
{
    ck.channel.name="MISSINGTUMORMARKER"
}
dapi.channel.name=metadata[input.dapi,"name"]
nucleus.channel.names=dapi.channel.name
if("type"%in%colnames(metadata))
{
    nucleus2.channel.names=metadata[sapply(strsplit(metadata$type,","),function(x){"nucleus2"%in%x}),"name"]
    if(length(nucleus2.channel.names)>0)
    {
        nucleus.channel.names=c(nucleus.channel.names,nucleus2.channel.names)
    }
    
}

if(!is.null(input.TLS))
{
    cat(paste0("[",format(Sys.time()),"] "),"loading",input.TLS,"\n")
    load(input.TLS)
    ##simple check
    if(!data.patches[,all(cell.ID==.I)])
        stop("problem with cell.ID")
}

##In the absence of tumor marker, add "other" tissue type
if(tumor_marker_present==FALSE&&!"other"%in%tissue.type.list)
    tissue.type.list=c(tissue.type.list,"other")

############################################
##load ROI
############################################
regions.of.interest=data.table(id=integer(0),label=character(0))
if(!is.null(input.ROI))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.ROI,"\n")
    regions.of.interest=fread(input.ROI)
    if(!"label"%in%colnames(regions.of.interest))
    {
        tmp=paste0("ROI ",seq_along(sort(unique(regions.of.interest$id))))
        names(tmp)=as.character(sort(unique(regions.of.interest$id)))        
        regions.of.interest[,label:=tmp[as.character(id)]]
    }
}
regions.of.interest.labels=sort(unique(regions.of.interest[,label]))
regions.of.interest.ids=lapply(regions.of.interest.labels,function(l){regions.of.interest[label==l,unique(id)]})
names(regions.of.interest.ids)=regions.of.interest.labels
#regions.of.interest.ids=unique(regions.of.interest[,.(label,id)])[order(label,id),id]

############################################
##load excluded region
############################################

excluded.regions=data.table(id=integer(0))
if(!is.null(input.excluded.regions))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.excluded.regions,"\n")
    excluded.regions=fread(input.excluded.regions)
}

############################################
##load or create phenotypes
############################################
cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
if(!is.null(input.phenotypes))
{
    cat(paste0("[",format(Sys.time()),"] "),"reading",input.phenotypes,"\n")
    phenotypes=as.data.frame(fread(input.phenotypes,sep="\t"))
    ##check
    if(!all(colnames(phenotypes)[-1]%in%rownames(metadata)))
    {
        stop("Invalid file --phenotypes=",input.phenotypes,". Channel column names must correspond to channel name defined in panel metadata/")
    }
    ##check
    if(!all(cols%in%colnames(phenotypes)[-1]))
    {
        stop("Invalid file --phenotypes=",input.phenotypes,". Missing channels: ",paste(cols[!cols%in%colnames(phenotypes)[-1]],collapse=", "))
    }    
}
if(is.null(input.phenotypes))
{
    ## create dummy phenotype list
    ##format: data.frame with column "label", and one column per channel (with colname channel name) with -/+/* (=negative/positive/anything)
    phenotypes=do.call("rbind",lapply(0:2,function(n){
        do.call("rbind",lapply(combn(length(cols),n,simplify=FALSE),function(x){
            tmp=matrix("-",ncol=length(cols),nrow=1,dimnames=list(NULL,cols))
            tmp[,x]="+"
            data.frame(tmp)
        }))
    }))
    ##set CK to *
    phenotypes[,input.ck]="*"
    phenotypes=unique(phenotypes)
    phenotypes=cbind(label="",phenotypes)
    ##create label
    for(col in cols)
    {
        channel.name=metadata[col,"name"]
        #phenotypes$label=paste0(phenotypes$label,ifelse(phenotypes[,col]%in%c("-","+"),paste0(col,phenotypes[,col]),""))
        phenotypes$label=paste0(phenotypes$label,ifelse(phenotypes[,col]=="+",paste0(channel.name,phenotypes[,col]),""))
    }
    phenotypes[phenotypes$label=="","label"]="Negative"

}


##check only -,+,*
if(!all(apply(phenotypes[,cols],1,function(x){all(x%in%c("-","+","*"))})))
{
    stop("Invalid file --phenotypes=",input.phenotypes)
}


###count number of positive channels (to reorder later)
cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]

##duplicate "*" into "-" and "+"
for(col in cols)
{
    tmp=phenotypes[phenotypes[,col]=="*",]
    if(nrow(tmp)>0)
    {
        phenotypes[phenotypes[,col]=="*",col]="-"
        tmp[,col]="+"
        phenotypes=rbind(phenotypes,tmp)
    }
}
##convert "-","+" to 0,1
phenotypes[,cols]=apply(phenotypes[,cols],2,function(x){ifelse(x=="+",1,0)})


overlapping_phenotypes=NULL
if(data.table(phenotypes)[,.(.N),by=cols][,any(N>1)])
{
    overlapping_phenotypes=phenotypes
    overlapping_phenotypes$phenotype.raw=""
    for(col in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
    {
        channel.name=metadata[col,"name"]
        overlapping_phenotypes$phenotype.raw=paste0(overlapping_phenotypes$phenotype.raw,channel.name,ifelse(overlapping_phenotypes[,col],"+","-"))
    }
    overlapping_phenotypes=split(overlapping_phenotypes$label,overlapping_phenotypes$phenotype.raw);
    overlapping_phenotypes=overlapping_phenotypes[lapply(overlapping_phenotypes,length)>1]
    ##stop("Invalid file --phenotypes=",input.phenotypes,". Overlapping phenotypes: ",paste("(",data.table(phenotypes)[,.(.N,label=paste(label,collapse=", ")),by=cols][N>1,label],")",collapse=" , ",sep=""))
}



##map phenotype raw <-> label
phenotypes.raw.to.label=phenotypes
### add raw to phenotypes.raw.to.label(concatenate <channel>+ or <channel>-)
phenotypes.raw.to.label$raw=""
for(col in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    channel.name=metadata[col,"name"]
    phenotypes.raw.to.label$raw=paste0(phenotypes.raw.to.label$raw,channel.name,ifelse(phenotypes.raw.to.label[,col]>0,"+","-"))
}
##find missing phenotypes (other)
cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
all.phenotypes=expand.grid(as.data.frame(matrix(rep(c(0,1),each=length(cols)),nrow=2,byrow=TRUE,dimnames=list(NULL,cols))))
all.phenotypes$raw=""
for(col in cols)
{
    channel.name=metadata[col,"name"]
    all.phenotypes$raw=paste0(all.phenotypes$raw,channel.name,ifelse(all.phenotypes[,col]>0,"+","-"))
}
other.phenotypes=all.phenotypes[!all.phenotypes$raw%in%phenotypes.raw.to.label$raw,]
if(nrow(other.phenotypes)>0)
    other.phenotypes=cbind(label=paste0("other (",other.phenotypes$raw,")"),other.phenotypes)
if(nrow(other.phenotypes)==0)
    other.phenotypes=cbind(label=character(0),other.phenotypes)

phenotypes.raw.to.label=data.table(unique(rbind(phenotypes.raw.to.label,other.phenotypes)[,c("label","raw")]))

############################################
## Evaluate score
############################################

cat(paste0("[",format(Sys.time()),"] "),"evaluating score\n")
if(is.null(nucleusFeatures.image))
{
    cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
    coln=c("cell.ID","nucleus.x","nucleus.y",paste0(cols,".score"))
    data.score=matrix(numeric(0),ncol=length(coln),nrow=0,dimnames=list(NULL,coln))
    coln=paste0(cols,".above.threshold")
    data.score.above.threshold=matrix(logical(0),ncol=length(coln),nrow=0,dimnames=list(NULL,coln))
}
if(!is.null(nucleusFeatures.image))
{
    data.score=nucleusFeatures.image[["shape"]][,c("cell.ID","nucleus.x","nucleus.y"),drop=FALSE]
    data.score.above.threshold=NULL
    for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
    {
        score.type=metadata.channel.thresholding[f,"score.type"]
        threshold=metadata.channel.thresholding[f,"threshold"]
        ##split score.type into summary statistic and region
        score.type.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",score.type)
        score.type.statistic=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",score.type)
        ##check
        if(!score.type.region%in%c("nucleus","extended.nucleus","around.nucleus"))
            stop("Invalid score type",score.type,". Accepted regions: nucleus, extended.nucleus or around.nucleus")
        if(!score.type.statistic%in%c("mean","median","q001","q005","q025","q075","q095","q099","circular.q005","circular.q010","circular.q025","circular.q050"))
            stop("Invalid score type ",score.type,". Accepted summary statistics: mean, median, q001, q005, q025, q075, q095, q099, circular.q005, circular.q010, circular.q025 or circular.q050")
        if(score.type.statistic=="median")score.type.statistic="q050"

        if(score.type.region=="nucleus")
        {
            data.score=cbind(data.score,nucleusFeatures.image[[f]][,score.type.statistic])
            data.score.above.threshold=cbind(data.score.above.threshold,nucleusFeatures.image[[f]][,score.type.statistic]>threshold)        
        }
        if(score.type.region=="extended.nucleus")
        {
            data.score=cbind(data.score,extendedNucleusFeatures.image[[f]][,score.type.statistic])
            data.score.above.threshold=cbind(data.score.above.threshold,extendedNucleusFeatures.image[[f]][,score.type.statistic]>threshold)
        }
        if(score.type.region=="around.nucleus")
        {
            data.score=cbind(data.score,aroundNucleusFeatures.image[[f]][,score.type.statistic])
            data.score.above.threshold=cbind(data.score.above.threshold,aroundNucleusFeatures.image[[f]][,score.type.statistic]>threshold)
        }
    }
    cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
    colnames(data.score)=c("cell.ID","nucleus.x","nucleus.y",paste0(cols,".score"))
    colnames(data.score.above.threshold)=paste0(cols,".above.threshold")
}

############################################
## merge & clean
############################################
rm(extendedNucleusFeatures.image)
rm(aroundNucleusFeatures.image)

setkey(voronoi.cells.summary,cell.ID)
##check cell.ID corresponds to row index
if(!voronoi.cells.summary[,all(cell.ID==.I)])
  stop("problem with cell.ID")
data.all=data.table(data.score,data.score.above.threshold,nucleus.area=nucleusFeatures.image[["shape"]][,c("nucleus.area")],voronoi.cells.summary[data.score[,"cell.ID"],.(tissue.type,area)])
setkey(data.all,cell.ID)
##check cell.ID corresponds to row index
if(!data.all[,all(cell.ID==.I)])
  stop("problem with cell.ID")
if(!is.null(input.TLS))
    data.all[,TLS.ID:=data.patches[data.all,patch.ID,on=.(cell.ID)]]

rm(nucleusFeatures.image)
rm(data.score)
rm(data.score.above.threshold)
rm(voronoi.cells.summary)

############################################
## add phenotypes
############################################

### create phenotype.raw (concatenate <channel>+ or <channel>-)
data.all[,phenotype.raw:=""]
for(col in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    channel.name=metadata[col,"name"]
    data.all$phenotype.raw=paste0(data.all$phenotype.raw,channel.name,ifelse(unlist(data.all[,paste0(col,".above.threshold"),with=FALSE]),"+","-"))
}


############################################
## flag cells to filter out 
############################################

data.all[,excluded:=FALSE]
if(!is.null(input.excluded.regions))
{
    ##exclude points
    for(i in excluded.regions[,unique(id)])
        data.all$excluded=data.all$excluded|(point.in.polygon(data.all$nucleus.x,data.all$nucleus.y,excluded.regions[id==i,x],excluded.regions[id==i,y])!=0)

}

##exclude "other" tissue type
data.all[!tissue.type%in%tissue.type.list,excluded:=TRUE]

data.all[,selected:=!excluded]

############################################
## flag cells in ROI
############################################

tumor_tissue_only.ROI.tokeep="Tumor tissue"
tumor_tissue_only.ROI.toremove=c("Adipose tissue","Host tissue","Necrosis","Next to tumor tissue")
if(!is.null(input.ROI))
{
    in.ROI=NULL
    for(roi.label.idx in seq_along(regions.of.interest.labels))
    {
        in.ROI.tmp=rep(FALSE,data.all[,.N])
        for(roi.id in regions.of.interest.ids[[roi.label.idx]])
            in.ROI.tmp=in.ROI.tmp|(point.in.polygon(data.all$nucleus.x,data.all$nucleus.y,regions.of.interest[id==roi.id,x],regions.of.interest[id==roi.id,y])!=0)
        if(is.null(in.ROI))
        {
            in.ROI=data.table(in.ROI.tmp)
        }
        else
        {
            in.ROI=cbind(in.ROI,in.ROI.tmp)
        }
    }
    setnames(in.ROI,paste0("in.ROI.",seq_along(regions.of.interest.labels)))
    data.all=cbind(data.all,in.ROI)
    ##add a column in.ROI._tumor_tissue_only_ that flag cell inside tumor tissue but not inside "Adipose tissue", "Host tissue", "Necrosis" nor "Next to tumor tissue"
    if(tumor_tissue_only.ROI.tokeep%in%regions.of.interest.labels)
    {
        tumor.idx=match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels)
        data.all[,in.ROI._tumor_tissue_only_:=.SD,.SDcols=paste0("in.ROI.",tumor.idx)]
        for(roi.label in tumor_tissue_only.ROI.toremove)
        {
            if(roi.label%in%regions.of.interest.labels)
            {
                roi.label.idx=match(roi.label,regions.of.interest.labels)
                data.all[,in.ROI._tumor_tissue_only_:=ifelse(.SD==TRUE,FALSE,in.ROI._tumor_tissue_only_),.SDcols=paste0("in.ROI.",roi.label.idx)]
            }
        }
    }
    else
    {
        ##no ROI "Tumor tissue"
        data.all[,in.ROI._tumor_tissue_only_:=FALSE]
    }
    
}

############################################
## selected tiles
############################################

##for each channel, find "interesting tiles"
tile.size=min(500,image.info$image.width.pixel,image.info$image.height.pixel)
sub.tile.size=ceiling(tile.size/3)

##add selected.tmp for cells inside ROI
data.all[,selected.tmp:=(!excluded)]
if(!is.null(input.ROI))
{
    data.all$selected.tmp=FALSE
    for(roi.label.idx in seq_along(regions.of.interest.labels))
        data.all$selected.tmp=data.all$selected.tmp|data.all[,.SD,.SDcols=paste0("in.ROI.",roi.label.idx)]
    data.all[excluded==TRUE,selected.tmp:=FALSE]    
}

##maximize the number of non-empty sub-tiles per tile (ideally inside ROI)
channels=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
ntiles.per.channel=length(channels)+1
selected.tiles=rbindlist(lapply(channels,function(channel){
    channel.name=metadata[channel,"name"]
    ##start with tiles overlapping ROIs (selected.tmp==TRUE)
    tmp=setnames(data.all[selected.tmp==TRUE,c("nucleus.x","nucleus.y",paste0(channel,".above.threshold")),with=FALSE],c("x","y","count"))[,count:=as.numeric(count)][count>0]
    tiles.tmp=head(tmp[,.(count=sum(count)),by=.(x,y,x.tile=floor(x/tile.size)*tile.size,y.tile=floor(y/tile.size)*tile.size)][,.(count=sum(count)),by=.(x.tile,y.tile,x.subtile=floor((x-x.tile)/sub.tile.size)*sub.tile.size,y.subtile=floor((y-y.tile)/sub.tile.size)*sub.tile.size)][,.(nb.nonempty.subtiles=sum(sign(count))),by=.(x=x.tile,y=y.tile)][sample.int(.N)][order(nb.nonempty.subtiles,decreasing=TRUE)],ntiles.per.channel)[,.(x,y)]

    ##fallback if no positive cells, use tiles with highest score sum
    if(nrow(tiles.tmp)<ntiles.per.channel)
    {
        tmp=data.all[selected.tmp==TRUE,c("nucleus.x","nucleus.y",paste0(channel,".score")),with=FALSE]
        setnames(tmp,c("x","y","score"))
        tiles.tmp=rbind(tiles.tmp,
                        head(tmp[,.(score=sum(score)),by=.(x=floor(x/tile.size)*tile.size,y=floor(y/tile.size)*tile.size)][sample.int(.N)][order(score,decreasing=TRUE)],ntiles.per.channel-nrow(tiles.tmp))[,.(x,y)]
                        )
    }
    ##fallback random tiles with cells
    if(nrow(tiles.tmp)<ntiles.per.channel)
    {
        tmp=data.all[selected.tmp==TRUE,.(nucleus.x,nucleus.y,count=1)]
        setnames(tmp,c("x","y","count"))
        tiles.tmp=rbind(tiles.tmp,
                        head(tmp[,.(count=sum(count)),by=.(x,y,x.tile=floor(x/tile.size)*tile.size,y.tile=floor(y/tile.size)*tile.size)][,.(count=sum(count)),by=.(x.tile,y.tile,x.subtile=floor((x-x.tile)/sub.tile.size)*sub.tile.size,y.subtile=floor((y-y.tile)/sub.tile.size)*sub.tile.size)][,.(nb.nonempty.subtiles=sum(sign(count))),by=.(x=x.tile,y=y.tile)][sample.int(.N)][order(nb.nonempty.subtiles,decreasing=TRUE)],ntiles.per.channel-nrow(tiles.tmp))[,.(x,y)]
                        )
    }

    ##Fallback: also try tiles ignoring ROIs (selected==TRUE)
    if(nrow(tiles.tmp)<ntiles.per.channel)
    {
        tmp=setnames(data.all[selected==TRUE,c("nucleus.x","nucleus.y",paste0(channel,".above.threshold")),with=FALSE],c("x","y","count"))[,count:=as.numeric(count)][count>0]
        tiles.tmp=head(tmp[,.(count=sum(count)),by=.(x,y,x.tile=floor(x/tile.size)*tile.size,y.tile=floor(y/tile.size)*tile.size)][,.(count=sum(count)),by=.(x.tile,y.tile,x.subtile=floor((x-x.tile)/sub.tile.size)*sub.tile.size,y.subtile=floor((y-y.tile)/sub.tile.size)*sub.tile.size)][,.(nb.nonempty.subtiles=sum(sign(count))),by=.(x=x.tile,y=y.tile)][sample.int(.N)][order(nb.nonempty.subtiles,decreasing=TRUE)],ntiles.per.channel)[,.(x,y)]
    }
    
    ##fallback if no positive cells, use tiles with highest score sum
    if(nrow(tiles.tmp)<ntiles.per.channel)
    {
        tmp=data.all[selected==TRUE,c("nucleus.x","nucleus.y",paste0(channel,".score")),with=FALSE]
        setnames(tmp,c("x","y","score"))
        tiles.tmp=rbind(tiles.tmp,
                        head(tmp[,.(score=sum(score)),by=.(x=floor(x/tile.size)*tile.size,y=floor(y/tile.size)*tile.size)][sample.int(.N)][order(score,decreasing=TRUE)],ntiles.per.channel-nrow(tiles.tmp))[,.(x,y)]
                        )
    }
    ##fallback random tiles with cells
    if(nrow(tiles.tmp)<ntiles.per.channel)
    {
        tmp=data.all[selected==TRUE,.(nucleus.x,nucleus.y,count=1)]
        setnames(tmp,c("x","y","count"))
        tiles.tmp=rbind(tiles.tmp,
                        head(tmp[,.(count=sum(count)),by=.(x,y,x.tile=floor(x/tile.size)*tile.size,y.tile=floor(y/tile.size)*tile.size)][,.(count=sum(count)),by=.(x.tile,y.tile,x.subtile=floor((x-x.tile)/sub.tile.size)*sub.tile.size,y.subtile=floor((y-y.tile)/sub.tile.size)*sub.tile.size)][,.(nb.nonempty.subtiles=sum(sign(count))),by=.(x=x.tile,y=y.tile)][sample.int(.N)][order(nb.nonempty.subtiles,decreasing=TRUE)],ntiles.per.channel-nrow(tiles.tmp))[,.(x,y)]
                        )
    }
    ##fallback random tiles inside clip.region
    if(nrow(tiles.tmp)<ntiles.per.channel)
    {
        tiles.tmp=rbind(tiles.tmp,
                        head(CJ(x=seq(clip.region["x.min"],max(clip.region["x.min"],clip.region["x.max"]-tile.size),by=tile.size),
                                y=seq(clip.region["y.min"],max(clip.region["y.min"],clip.region["y.max"]-tile.size),by=tile.size))[sample.int(.N)],
                             ntiles.per.channel-nrow(tiles.tmp))
                        )
    }
    ##fallback random tiles
    if(nrow(tiles.tmp)<ntiles.per.channel)
    {
        tiles.tmp=rbind(tiles.tmp,
                        head(CJ(x=seq(0,max(0,image.info$image.width.pixel-tile.size),by=tile.size),
                                y=seq(0,max(0,image.info$image.height.pixel-tile.size),by=tile.size))[sample.int(.N)],
                             ntiles.per.channel-nrow(tiles.tmp))
                        )
    }
    if(nrow(tiles.tmp)>0)
    {
        ##add width & height
        tiles.tmp[,width:=pmin(tile.size,image.info$image.width.pixel-x)]
        tiles.tmp[,height:=pmin(tile.size,image.info$image.height.pixel-y)]
    }
    
    tiles.tmp[,.(x,y,width,height,channel=channel,rank=1:.N)]
}))
##add tissue type
##start with tiles overlapping ROIs (selected.tmp==TRUE)
tmp=data.all[selected.tmp==TRUE,.(nucleus.x,nucleus.y,tissue.type)][tissue.type%in%tissue.type.list,.(x=nucleus.x,y=nucleus.y,count.stroma=ifelse(tissue.type=="stroma",1,0),count.tumor=ifelse(tissue.type=="tumor",1,0))]
tiles.tmp=head(tmp[,.(count.stroma=sum(count.stroma),count.tumor=sum(count.tumor)),by=.(x,y,x.tile=floor(x/tile.size)*tile.size,y.tile=floor(y/tile.size)*tile.size)][,.(count.stroma=sum(count.stroma),count.tumor=sum(count.tumor)),by=.(x.tile,y.tile,x.subtile=floor((x-x.tile)/sub.tile.size)*sub.tile.size,y.subtile=floor((y-y.tile)/sub.tile.size)*sub.tile.size)][,.(stroma.nb.nonempty.subtiles=sum(sign(count.stroma)),tumor.nb.nonempty.subtiles=sum(sign(count.tumor))),by=.(x=x.tile,y=y.tile)][sample.int(.N),][order(stroma.nb.nonempty.subtiles+tumor.nb.nonempty.subtiles-abs(stroma.nb.nonempty.subtiles-tumor.nb.nonempty.subtiles),decreasing=TRUE)],ntiles.per.channel)[,.(x,y)]
##fallback: also try ignoring ROI (selected==TRUE)
if(nrow(tiles.tmp)<ntiles.per.channel)
{
    tmp=data.all[selected==TRUE,.(nucleus.x,nucleus.y,tissue.type)][tissue.type%in%tissue.type.list,.(x=nucleus.x,y=nucleus.y,count.stroma=ifelse(tissue.type=="stroma",1,0),count.tumor=ifelse(tissue.type=="tumor",1,0))]
    tiles.tmp=rbind(tiles.tmp,
                    head(tmp[,.(count.stroma=sum(count.stroma),count.tumor=sum(count.tumor)),by=.(x,y,x.tile=floor(x/tile.size)*tile.size,y.tile=floor(y/tile.size)*tile.size)][,.(count.stroma=sum(count.stroma),count.tumor=sum(count.tumor)),by=.(x.tile,y.tile,x.subtile=floor((x-x.tile)/sub.tile.size)*sub.tile.size,y.subtile=floor((y-y.tile)/sub.tile.size)*sub.tile.size)][,.(stroma.nb.nonempty.subtiles=sum(sign(count.stroma)),tumor.nb.nonempty.subtiles=sum(sign(count.tumor))),by=.(x=x.tile,y=y.tile)][sample.int(.N),][order(stroma.nb.nonempty.subtiles+tumor.nb.nonempty.subtiles-abs(stroma.nb.nonempty.subtiles-tumor.nb.nonempty.subtiles),decreasing=TRUE)],ntiles.per.channel)[,.(x,y)]
                    )

}
##fallback random tiles inside clip.region
if(nrow(tiles.tmp)<ntiles.per.channel)
{
    tiles.tmp=rbind(tiles.tmp,
                    head(CJ(x=seq(clip.region["x.min"],max(clip.region["x.min"],clip.region["x.max"]-tile.size),by=tile.size),
                            y=seq(clip.region["y.min"],max(clip.region["y.min"],clip.region["y.max"]-tile.size),by=tile.size))[sample.int(.N)],
                         ntiles.per.channel-nrow(tiles.tmp))
                    )
}
##fallback random tiles 
if(nrow(tiles.tmp)<ntiles.per.channel)
{
    tiles.tmp=rbind(tiles.tmp,
                    head(CJ(x=seq(0,image.info$image.width.pixel-tile.size,by=tile.size),
                            y=seq(0,image.info$image.height.pixel-tile.size,by=tile.size))[sample.int(.N)],
                         ntiles.per.channel-nrow(tiles.tmp))
                    )
}
if(nrow(tiles.tmp)>0)
{
    ##add width & height
    tiles.tmp[,width:=pmin(tile.size,image.info$image.width.pixel-x)]
    tiles.tmp[,height:=pmin(tile.size,image.info$image.height.pixel-y)]
    selected.tiles=rbind(selected.tiles,tiles.tmp[,.(x,y,width,height,channel="tissue.type",rank=1:.N)])
}

##remove temporary column
data.all[,selected.tmp:=NULL]


setorder(selected.tiles,rank)
##remove duplicated & keep one per channel
selected.tiles=head(selected.tiles[!duplicated(selected.tiles[,.(x,y)])],length(channels)+1)

############################################
##create list of phenotypes
############################################
##list of phenotypes, ordered by total count (with "other" at the end)
phenotypes.list=rbindlist(lapply(phenotypes.raw.to.label[,unique(gsub("^other.*","other",label))],function(phenotype.label){
    phenotype.raw.tmp=phenotypes.raw.to.label[gsub("^other.*","other",label)==phenotype.label,raw]
    data.all[selected==TRUE&phenotype.raw%in%phenotype.raw.tmp,.(phenotype.label,count=.N)]
}))[data.table(phenotype.label=unique(c(phenotypes$label,"other"))),on="phenotype.label"][order(phenotype.label=="other",-count,phenotype.label,na.last=TRUE)][,phenotype.label]


##phenotypes colors
nphenotypes=length(phenotypes.list)
palette="Paired"
if(brewer.pal.info[palette,"maxcolors"]>=nphenotypes)
{
    phenotypes.colors=brewer.pal(nphenotypes, palette)
}
if(brewer.pal.info[palette,"maxcolors"]<nphenotypes)
{
    phenotypes.colors=colorRampPalette(brewer.pal(brewer.pal.info[palette,"maxcolors"], palette))(nphenotypes)
    phenotypes.colors=phenotypes.colors[sample.int(length(phenotypes.colors))]
}
names(phenotypes.colors)=phenotypes.list


############################################
##create composite plot
############################################

w=image.info$image.width.pixel
h=image.info$image.height.pixel
out.size.max.inches=7
legend.size.inches=0 #no legend
out.width=w*out.size.max.inches/max(h,w)+legend.size.inches
out.height=h*out.size.max.inches/max(h,w)

filename=paste0(tmpdir,"/image_composite.pdf")
cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
pdf(filename,out.width,out.height,fillOddEven=TRUE) #fillOddEven to have polygon() filled with same rule as point.in.polygon()
par(mar=c(0.3,0,0.3,0))#same top/bottom margin as cell density

##plot composite image using binned data
xlevels=seq(0,image.info$image.width.pixel,by=data.binned.binsize)
ylevels=seq(0,image.info$image.height.pixel,by=data.binned.binsize)
data.binned[,x.factor:=factor(x,levels=xlevels)]
data.binned[,y.factor:=factor(y,levels=ylevels)]

##eval composite image r,g,b
color.r=as.numeric(sapply(strsplit(metadata[,"color"],","),function(x){x[1]}))/255
color.g=as.numeric(sapply(strsplit(metadata[,"color"],","),function(x){x[2]}))/255
color.b=as.numeric(sapply(strsplit(metadata[,"color"],","),function(x){x[3]}))/255
names(color.r)=rownames(metadata)
names(color.g)=rownames(metadata)
names(color.b)=rownames(metadata)
data.binned[,composite.r:=0]
data.binned[,composite.g:=0]
data.binned[,composite.b:=0]
data.binned[,composite.r:=as.matrix(data.binned[,.SD,.SDcols=rownames(metadata)])[,rownames(metadata)]%*%(color.r[rownames(metadata)]/channel.normalization[rownames(metadata)])]
data.binned[,composite.g:=as.matrix(data.binned[,.SD,.SDcols=rownames(metadata)])[,rownames(metadata)]%*%(color.g[rownames(metadata)]/channel.normalization[rownames(metadata)])]
data.binned[,composite.b:=as.matrix(data.binned[,.SD,.SDcols=rownames(metadata)])[,rownames(metadata)]%*%(color.b[rownames(metadata)]/channel.normalization[rownames(metadata)])]

##normalize to 99.9 percentile
plot.global.normalization.factor=quantile(as.matrix(data.binned[is.valid>0,.SD,.SDcols=rownames(metadata)[!metadata$channel%in%c(channel.autofluorescence)]]),probs=0.999)
data.binned[,composite.r:=composite.r/plot.global.normalization.factor]
data.binned[,composite.g:=composite.g/plot.global.normalization.factor]
data.binned[,composite.b:=composite.b/plot.global.normalization.factor]

image.r=data.table::dcast(data.binned,x.factor~y.factor,value.var="composite.r",fill=0,drop=FALSE)
image.r=as.Image(as.matrix(image.r[,-1]))

image.g=data.table::dcast(data.binned,x.factor~y.factor,value.var="composite.g",fill=0,drop=FALSE)
image.g=as.Image(as.matrix(image.g[,-1]))

image.b=data.table::dcast(data.binned,x.factor~y.factor,value.var="composite.b",fill=0,drop=FALSE)
image.b=as.Image(as.matrix(image.b[,-1]))

##show outside of clip.region as grey
clip.region["x.min"]=min(image.info$image.width.pixel,max(0,clip.region["x.min"]))
clip.region["x.max"]=max(0,min(image.info$image.width.pixel,clip.region["x.max"]))
clip.region["y.min"]=max(0,min(image.info$image.height.pixel,max(0,clip.region["y.min"])))
clip.region["y.max"]=min(image.info$image.height.pixel,clip.region["y.max"])
clip.region.tmp=c(x.min=floor(unname(clip.region["x.min"])/data.binned.binsize)+1,
                     y.min=floor(unname(clip.region["y.min"])/data.binned.binsize)+1,
                     x.max=floor(unname(clip.region["x.max"])/data.binned.binsize)+1,
                     y.max=floor(unname(clip.region["y.max"])/data.binned.binsize)+1)

if(clip.region.tmp["x.min"]>1)
{
    image.r[1:(clip.region.tmp["x.min"]-1),]=0.75
    image.g[1:(clip.region.tmp["x.min"]-1),]=0.75
    image.b[1:(clip.region.tmp["x.min"]-1),]=0.75
}
if(clip.region.tmp["y.min"]>1)
{
    image.r[,1:(clip.region.tmp["y.min"]-1)]=0.75
    image.g[,1:(clip.region.tmp["y.min"]-1)]=0.75
    image.b[,1:(clip.region.tmp["y.min"]-1)]=0.75
}
if(clip.region.tmp["x.max"]<nrow(image.r))
{
    image.r[(clip.region.tmp["x.max"]+1):nrow(image.r),]=0.75
    image.g[(clip.region.tmp["x.max"]+1):nrow(image.r),]=0.75
    image.b[(clip.region.tmp["x.max"]+1):nrow(image.r),]=0.75
}
if(clip.region.tmp["y.max"]<ncol(image.r))
{
    image.r[,(clip.region.tmp["y.max"]+1):ncol(image.r)]=0.75
    image.g[,(clip.region.tmp["y.max"]+1):ncol(image.r)]=0.75
    image.b[,(clip.region.tmp["y.max"]+1):ncol(image.r)]=0.75
}





image.r[image.r>1]=1
image.g[image.g>1]=1
image.b[image.b>1]=1
image_composite=rgbImage(image.r,image.g,image.b)
plot(as.raster(image_composite[,ncol(image_composite):1,]),ylim=c(ncol(image_composite),0),interpolate=FALSE)

##add tiles
for(n in 1:nrow(selected.tiles))
{
    rect(xleft=selected.tiles[n,"x"]/data.binned.binsize,ybottom=(selected.tiles[n,"y"]+selected.tiles[n,"height"])/data.binned.binsize,xright=(selected.tiles[n,"x"]+selected.tiles[n,"width"])/data.binned.binsize,ytop=selected.tiles[n,"y"]/data.binned.binsize,border="white",lwd=1,col=rgb(0,0,0,0.4))
    text(x=(selected.tiles[n,"x"]+selected.tiles[n,"width"]/2)/data.binned.binsize,y=(selected.tiles[n,"y"]+selected.tiles[n,"height"]/2)/data.binned.binsize,label=n,cex=0.4,col="white",font=2)
}

##add excluded regions
for(i in excluded.regions[,unique(id)])
    polygon(excluded.regions[id==i,.(x/data.binned.binsize,y/data.binned.binsize)],border=rgb(1,0,0,0.9),col=rgb(0.5,0,0,0.3),lwd=1)

##add regions of interest (ROI)
for(i in seq_along(regions.of.interest.labels))
{
    for(roi.id in regions.of.interest.ids[[i]])
    {
        polygon(regions.of.interest[id==roi.id,.(x/data.binned.binsize,y/data.binned.binsize)],border=rgb(0,1,0,0.9),col=rgb(0,0.5,0,0.3),lwd=1)
        text(x=regions.of.interest[id==roi.id,mean(x)/data.binned.binsize],y=regions.of.interest[id==roi.id,mean(y)/data.binned.binsize],label=i,cex=0.5,col="green",font=2)
    }
}


##add scale
image.width.micron=convert.image.to.slide.length(image.info$image.width.pixel,image.info)
##we want approx 1/5 of image width
tmp=pretty(c(0,image.width.micron),n=7)
bar.width.micron=tmp[2]-tmp[1]
##convert to image coordinates (1 pixel in this image = data.binned.binsize original image pixel)
bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/data.binned.binsize
space=0.01*max(ncol(image_composite),nrow(image_composite))
lines(x=space+c(0,bar.width),y=(ncol(image_composite)-space)*c(1,1),col="white",lwd=2)
text(x=space+bar.width/2,y=ncol(image_composite)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="white",pos=3,cex=0.6,offset=0.2)


dev.off()

##create composite plot with ROI regions only
roi.label.idx.list=seq_along(regions.of.interest.labels)
if(length(regions.of.interest.labels)>1)roi.label.idx.list=c(roi.label.idx.list,list(seq_along(regions.of.interest.labels)))
if(tumor_tissue_only.ROI.tokeep%in%regions.of.interest.labels)roi.label.idx.list=c(roi.label.idx.list,-1)
for(roi.label.idx in roi.label.idx.list)
{
    filename=paste0(tmpdir,"/image_composite_roi_",paste(roi.label.idx,collapse="_"),".pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,out.width,out.height,fillOddEven=TRUE) #fillOddEven to have polygon() filled with same rule as point.in.polygon()
    par(mar=c(0.3,0,0.3,0))#same top/bottom margin as cell density
    plot(as.raster(image_composite[,ncol(image_composite):1,]),ylim=c(ncol(image_composite),0),interpolate=FALSE)

    ##add regions of interest (ROI)
    if(length(roi.label.idx)==1&&roi.label.idx==-1)
    {
        ##tumor tissue without other ROIs
        tumor.idx=match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels)
        for(i in seq_along(regions.of.interest.labels[tumor.idx]))
        {
            for(roi.id in regions.of.interest.ids[tumor.idx][[i]])
            {
                polygon(regions.of.interest[id==roi.id,.(x/data.binned.binsize,y/data.binned.binsize)],border=rgb(0,1,0,0.9),col=rgb(0,0.5,0,0.3),lwd=1)
                text(x=regions.of.interest[id==roi.id,mean(x)/data.binned.binsize],y=regions.of.interest[id==roi.id,mean(y)/data.binned.binsize],label=tumor.idx[i],cex=0.5,col="green",font=2)
            }
        }
        ##ROI to remove, in red
        toremove.idx=match(tumor_tissue_only.ROI.toremove,regions.of.interest.labels)
        toremove.idx=toremove.idx[!is.na(toremove.idx)]
        for(i in seq_along(regions.of.interest.labels[toremove.idx]))
        {
            for(roi.id in regions.of.interest.ids[toremove.idx][[i]])
            {
                polygon(regions.of.interest[id==roi.id,.(x/data.binned.binsize,y/data.binned.binsize)],border=rgb(1,0,0,0.9),col=rgb(0.5,0,0,0.5),lwd=1)
                text(x=regions.of.interest[id==roi.id,mean(x)/data.binned.binsize],y=regions.of.interest[id==roi.id,mean(y)/data.binned.binsize],label=toremove.idx[i],cex=0.5,col="red",font=2)
            }
        }
        
    }
    else
    {
        for(i in seq_along(regions.of.interest.labels[roi.label.idx]))
        {
            for(roi.id in regions.of.interest.ids[roi.label.idx][[i]])
            {
                polygon(regions.of.interest[id==roi.id,.(x/data.binned.binsize,y/data.binned.binsize)],border=rgb(0,1,0,0.9),col=rgb(0,0.5,0,0.3),lwd=1)
                text(x=regions.of.interest[id==roi.id,mean(x)/data.binned.binsize],y=regions.of.interest[id==roi.id,mean(y)/data.binned.binsize],label=roi.label.idx[i],cex=0.5,col="green",font=2)
            }
        }
    }
    ##add scale
    image.width.micron=convert.image.to.slide.length(image.info$image.width.pixel,image.info)
    ##we want approx 1/5 of image width
    tmp=pretty(c(0,image.width.micron),n=7)
    bar.width.micron=tmp[2]-tmp[1]
    ##convert to image coordinates (1 pixel in this image = data.binned.binsize original image pixel)
    bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/data.binned.binsize
    space=0.01*max(ncol(image_composite),nrow(image_composite))
    lines(x=space+c(0,bar.width),y=(ncol(image_composite)-space)*c(1,1),col="white",lwd=2)
    text(x=space+bar.width/2,y=ncol(image_composite)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="white",pos=3,cex=0.6,offset=0.2)

    dev.off()
}

############################################
##create plots for selected tiles
############################################
color.dapi.r=as.numeric(strsplit(metadata[input.dapi,"color"],",")[[1]])[1]/255
color.dapi.g=as.numeric(strsplit(metadata[input.dapi,"color"],",")[[1]])[2]/255
color.dapi.b=as.numeric(strsplit(metadata[input.dapi,"color"],",")[[1]])[3]/255
if(tumor_marker_present)
{
    color.ck.r=as.numeric(strsplit(metadata[input.ck,"color"],",")[[1]])[1]/255
    color.ck.g=as.numeric(strsplit(metadata[input.ck,"color"],",")[[1]])[2]/255
    color.ck.b=as.numeric(strsplit(metadata[input.ck,"color"],",")[[1]])[3]/255
}
channel.ck=metadata[input.ck,"channel"]
for(i in 1:nrow(selected.tiles))
{
    tile=c(x=selected.tiles[i,x],y=selected.tiles[i,y],width=selected.tiles[i,width],height=selected.tiles[i,height])
    image.info.tile=image.info
    image.info.tile[["tile.x"]]=tile["x"]
    image.info.tile[["tile.y"]]=tile["y"]
    image.info.tile[["tile.width"]]=tile["width"]
    image.info.tile[["tile.height"]]=tile["height"]
    cat(paste0("[",format(Sys.time()),"] "),"Tile: x=",tile[["x"]]," y=",tile[["y"]]," width=",tile[["width"]]," height=",tile[["height"]],"\n")

    tmpfile=tempfile(fileext="_channel_%c.png",tmpdir=tmpdir)
    cat(paste0("[",format(Sys.time()),"] "),"temp file:",tmpfile,"\n")
    system2("bfconvert",args=c("-no-upgrade",paste0("-crop ",tile[["x"]],",",tile[["y"]],",",tile[["width"]],",",tile[["height"]]),"-series 0",paste0("\"",input.image,"\""),paste0("\"",tmpfile,"\"")))

    files.tmp=list.files(tmpdir,pattern=gsub("_channel_%c.png","_channel_[0-9]*.png",basename(tmpfile)),full.name=TRUE)
    images=lapply(files.tmp,function(f)
    {
        channel=gsub(".*_(channel_[0-9]*).*","\\1",basename(f))
        image=readImage(f)
        image=image/image.info$image.exposure.times[channel]
        file.remove(f)
        image
    })
    names(images)=gsub(".*_(channel_[0-9]*).*","\\1",basename(files.tmp))

    ##ignore regions with all values at zero (set to NA)
    image.is.valid.tmp=sign(Reduce("+",images))!=0 #TRUE if not all zero, FALSE if all channels at 0
    clip.region.tile=c(convert.image.to.tile.position.x(clip.region["x.min"],image.info.tile),
                       convert.image.to.tile.position.y(clip.region["y.min"],image.info.tile),
                       convert.image.to.tile.position.x(clip.region["x.max"],image.info.tile),
                       convert.image.to.tile.position.y(clip.region["y.max"],image.info.tile))
    clip.region.tile=c(x.min=min(image.info.tile$tile.width+1,max(1,clip.region.tile["x.min"])),
                       y.min=min(image.info.tile$tile.height+1,max(1,clip.region.tile["y.min"])),
                       x.max=min(image.info.tile$tile.width,max(0,clip.region.tile["x.max"])),
                       y.max=min(image.info.tile$tile.height,max(0,clip.region.tile["y.max"])))
    if(clip.region.tile["x.min"]>1)
        image.is.valid.tmp[1:(clip.region.tile["x.min"]-1),]=0
    if(clip.region.tile["y.min"]>1)
        image.is.valid.tmp[,1:(clip.region.tile["y.min"]-1)]=0
    if(clip.region.tile["x.max"]<image.info.tile$tile.width)
        image.is.valid.tmp[(clip.region.tile["x.max"]+1):image.info.tile$tile.width,]=0
    if(clip.region.tile["y.max"]<image.info.tile$tile.height)
        image.is.valid.tmp[,(clip.region.tile["y.max"]+1):image.info.tile$tile.height]=0

    ##unmix image
    cat(paste0("[",format(Sys.time()),"] "),"unmixing and removing AF\n")
    images=unmix_images(images,unmixing.parameters)

    for(f in names(images))
    {
        images[[f]][!image.is.valid.tmp]=0
    }

    ##normalize
    for(f in names(images))
    {
        images[[f]]=images[[f]]/plot.global.normalization.factor/channel.normalization[f]
        images[[f]][images[[f]]>1]=1
    }

    out.size.max.inches=7
    out.width=tile["width"]*out.size.max.inches/max(tile["height"],tile["width"])
    out.height=tile["height"]*out.size.max.inches/max(tile["height"],tile["width"])

    ####################
    ##channel intensity, with DAPI and CK
    for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.ck,channel.autofluorescence)])
    {
        ##channel
        channel.name=metadata[f,"name"]
        color.r=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[1]/255
        color.g=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[2]/255
        color.b=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[3]/255
        if(tumor_marker_present&&f!=input.ck)##add CK
        {
            tmp.r=color.r*images[[f]]+color.dapi.r*images[[input.dapi]]+color.ck.r*images[[input.ck]]
            tmp.g=color.g*images[[f]]+color.dapi.g*images[[input.dapi]]+color.ck.g*images[[input.ck]]
            tmp.b=color.b*images[[f]]+color.dapi.b*images[[input.dapi]]+color.ck.b*images[[input.ck]]
        }
        else##do not add CK
        {
            tmp.r=color.r*images[[f]]+color.dapi.r*images[[input.dapi]]
            tmp.g=color.g*images[[f]]+color.dapi.g*images[[input.dapi]]
            tmp.b=color.b*images[[f]]+color.dapi.b*images[[input.dapi]]
        }
        tmp.r[tmp.r>1]=1
        tmp.g[tmp.g>1]=1
        tmp.b[tmp.b>1]=1
        image=rgbImage(tmp.r,tmp.g,tmp.b)
        
        filename=paste0(tmpdir,"/selected_tile_",i,"_",f,".pdf")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        pdf(filename,out.width,out.height)
        par(mar=c(0,0,0,0))
        
        plot(as.raster(image[,ncol(image):1,]),ylim=c(ncol(image),0),interpolate=FALSE)

        ##add scale
        tile.width.micron=convert.image.to.slide.length(tile["width"],image.info)
        ##we want approx 1/5 of image width
        tmp=pretty(c(0,tile.width.micron),n=7)
        bar.width.micron=tmp[2]-tmp[1]
        ##convert to image coordinates
        bar.width=convert.slide.to.image.length(bar.width.micron,image.info)
        space=0.01*max(ncol(image),nrow(image))
        lines(x=space+c(0,bar.width),y=(ncol(image)-space)*c(1,1),col="white",lwd=3)
        text(x=space+bar.width/2,y=ncol(image)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="white",pos=3,cex=1.5,offset=0.3)
        
        dev.off()
    }
    ####################
    ##<channel>-positive cells with DAPI
    for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
    {
        ##channel
        channel.name=metadata[f,"name"]
        color.r=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[1]/255
        color.g=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[2]/255
        color.b=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[3]/255
        ##add dapi
        tmp.r=color.r*images[[f]]+color.dapi.r*images[[input.dapi]]
        tmp.g=color.g*images[[f]]+color.dapi.g*images[[input.dapi]]
        tmp.b=color.b*images[[f]]+color.dapi.b*images[[input.dapi]]
        tmp.r[tmp.r>1]=1
        tmp.g[tmp.g>1]=1
        tmp.b[tmp.b>1]=1
        image=rgbImage(tmp.r,tmp.g,tmp.b)
        
        filename=paste0(tmpdir,"/selected_tile_",i,"_",f,"_positive_cells.pdf")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        pdf(filename,out.width,out.height)
        par(mar=c(0,0,0,0))
        
        plot(as.raster(image[,ncol(image):1,]),ylim=c(ncol(image),0),interpolate=FALSE)

        ##add nuclei center
        tmp=setnames(data.all[selected==TRUE,c("nucleus.x","nucleus.y",paste0(f,".above.threshold")),with=FALSE],c("nucleus.x","nucleus.y","channel.above.threshold"))[nucleus.x>=tile["x"]&nucleus.y>=tile["y"]&nucleus.x<=tile["x"]+tile["width"]&nucleus.y<=tile["y"]+tile["height"],.(nucleus.x=convert.image.to.tile.position.x(nucleus.x,image.info.tile),nucleus.y=convert.image.to.tile.position.y(nucleus.y,image.info.tile),channel.above.threshold)]
        points(tmp[channel.above.threshold==TRUE,.(nucleus.x,nucleus.y)],col="white",pch=21,cex=1,bg="red")
        points(tmp[channel.above.threshold==FALSE,.(nucleus.x,nucleus.y)],col="white",pch=21,bg="white",cex=0.3,lwd=0.5)
        
        dev.off()
    }

    ####################
    ##dapi with nuclei centers
    f=input.dapi
    channel.name=metadata[f,"name"]
    color.r=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[1]/255
    color.g=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[2]/255
    color.b=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[3]/255
    if(tumor_marker_present)##add CK
    {
        tmp.r=color.r*images[[f]]+color.ck.r*images[[input.ck]]
        tmp.g=color.g*images[[f]]+color.ck.g*images[[input.ck]]
        tmp.b=color.b*images[[f]]+color.ck.b*images[[input.ck]]
    }
    else##only dapi
    {
        tmp.r=color.r*images[[f]]
        tmp.g=color.g*images[[f]]
        tmp.b=color.b*images[[f]]
    }

    tmp.r[tmp.r>1]=1
    tmp.g[tmp.g>1]=1
    tmp.b[tmp.b>1]=1
    image=rgbImage(tmp.r,tmp.g,tmp.b)
    
    filename=paste0(tmpdir,"/selected_tile_",i,"_cell_segmentation.pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,out.width,out.height)
    par(mar=c(0,0,0,0))
    
    plot(as.raster(image[,ncol(image):1,]),ylim=c(ncol(image),0),interpolate=FALSE)
    ##add nuclei centers
    tmp=data.all[selected==TRUE,.(nucleus.x,nucleus.y)][nucleus.x>=tile["x"]&nucleus.y>=tile["y"]&nucleus.x<=tile["x"]+tile["width"]&nucleus.y<=tile["y"]+tile["height"],.(nucleus.x=convert.image.to.tile.position.x(nucleus.x,image.info.tile),nucleus.y=convert.image.to.tile.position.y(nucleus.y,image.info.tile))]
    points(tmp[,.(nucleus.x,nucleus.y)],col="green",cex=0.5)
    
    dev.off()


    ####################
    ##CK with CK positive/negative
    if(tumor_marker_present)
    {
        f=input.ck
        channel.name=metadata[f,"name"]
        color.r=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[1]/255
        color.g=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[2]/255
        color.b=as.numeric(strsplit(metadata[f,"color"],",")[[1]])[3]/255
        ##do not add CK
        tmp.r=color.r*images[[f]]+color.dapi.r*images[[input.dapi]]
        tmp.g=color.g*images[[f]]+color.dapi.g*images[[input.dapi]]
        tmp.b=color.b*images[[f]]+color.dapi.b*images[[input.dapi]]

        tmp.r[tmp.r>1]=1
        tmp.g[tmp.g>1]=1
        tmp.b[tmp.b>1]=1
        image=rgbImage(tmp.r,tmp.g,tmp.b)
        
        filename=paste0(tmpdir,"/selected_tile_",i,"_tissue_segmentation_ck.pdf")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        pdf(filename,out.width,out.height)
        par(mar=c(0,0,0,0))
        
        plot(as.raster(image[,ncol(image):1,]),ylim=c(ncol(image),0),interpolate=FALSE)
        ##add nuclei center
        tmp=setnames(data.all[selected==TRUE,c("nucleus.x","nucleus.y",paste0(f,".above.threshold")),with=FALSE],c("nucleus.x","nucleus.y","channel.above.threshold"))[nucleus.x>=tile["x"]&nucleus.y>=tile["y"]&nucleus.x<=tile["x"]+tile["width"]&nucleus.y<=tile["y"]+tile["height"],.(nucleus.x=convert.image.to.tile.position.x(nucleus.x,image.info.tile),nucleus.y=convert.image.to.tile.position.y(nucleus.y,image.info.tile),channel.above.threshold)]
        points(tmp[channel.above.threshold==TRUE,.(nucleus.x,nucleus.y)],col="red",pch=21,cex=1,bg="red")
        points(tmp[channel.above.threshold==FALSE,.(nucleus.x,nucleus.y)],col="white",pch=21,bg="white",cex=0.3,lwd=0.5)
        
        dev.off()

####################
        ##CK with tissue type
        filename=paste0(tmpdir,"/selected_tile_",i,"_tissue_segmentation.pdf")
        cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
        pdf(filename,out.width,out.height)
        par(mar=c(0,0,0,0))    
        plot(as.raster(image[,ncol(image):1,]),ylim=c(ncol(image),0),interpolate=FALSE)

        tissue.color=c(other=rgb(0,0,1,0.3),stroma=rgb(0,1,0,0.3),tumor=rgb(1,0,0,0.3))
        for(tt in names(tissue.color))
        {
            ##insert NA between consecutive cells
            tmp=voronoi.cells[tissue.type==tt]
            tmp=tmp[,.(keep=any(x>=tile["x"]&x<=tile["x"]+tile["width"]&y>=tile["y"]&y<=tile["y"]+tile["height"])),by=.(cell.ID)]
            tmp=tmp[keep==TRUE,cell.ID]
            polygon(voronoi.cells[cell.ID%in%tmp,.(x=c(x,NA),y=c(y,NA)),by=cell.ID][,.(x=convert.image.to.tile.position.x(x,image.info.tile),y=convert.image.to.tile.position.y(y,image.info.tile))],border=rgb(0,0,0,0.5),col=tissue.color[tt])
        }

        ##add nuclei center
        tmp=setnames(data.all[selected==TRUE,c("nucleus.x","nucleus.y",paste0(f,".above.threshold")),with=FALSE],c("nucleus.x","nucleus.y","channel.above.threshold"))[nucleus.x>=tile["x"]&nucleus.y>=tile["y"]&nucleus.x<=tile["x"]+tile["width"]&nucleus.y<=tile["y"]+tile["height"],.(nucleus.x=convert.image.to.tile.position.x(nucleus.x,image.info.tile),nucleus.y=convert.image.to.tile.position.y(nucleus.y,image.info.tile),channel.above.threshold)]
        points(tmp[channel.above.threshold==TRUE,.(nucleus.x,nucleus.y)],col="red",pch=21,cex=1,bg="red")
        points(tmp[channel.above.threshold==FALSE,.(nucleus.x,nucleus.y)],col="white",pch=21,bg="white",cex=0.3,lwd=0.5)

        
        dev.off()
    }
}

##############################
##clip
##############################
clip.region.binned=c(x.min=floor(unname(clip.region["x.min"])/data.binned.binsize)*data.binned.binsize,
                     y.min=floor(unname(clip.region["y.min"])/data.binned.binsize)*data.binned.binsize,
                     x.max=ceiling(unname(clip.region["x.max"])/data.binned.binsize)*data.binned.binsize,
                     y.max=ceiling(unname(clip.region["y.max"])/data.binned.binsize)*data.binned.binsize)

xlevels=xlevels[xlevels>=clip.region.binned["x.min"]&xlevels<=clip.region.binned["x.max"]]
ylevels=ylevels[ylevels>=clip.region.binned["y.min"]&ylevels<=clip.region.binned["y.max"]]
data.binned[,clipped:=x>=clip.region.binned["x.min"]&x<=clip.region.binned["x.max"]&y>=clip.region.binned["y.min"]&y<=clip.region.binned["y.max"]]
data.binned=data.binned[clipped==TRUE]
data.binned[,x.factor:=factor(x,levels=xlevels)]
data.binned[,y.factor:=factor(y,levels=ylevels)]

clipped.image.width.pixel=clip.region["x.max"]-clip.region["x.min"]
clipped.image.height.pixel=clip.region["y.max"]-clip.region["y.min"]

##############################
##create QC plot (dapi sharpness)
##############################
w=clipped.image.width.pixel
h=clipped.image.height.pixel
out.size.max.inches=7
legend.size.inches=0 #no legend
out.width=w*out.size.max.inches/max(h,w)+legend.size.inches
out.height=h*out.size.max.inches/max(h,w)

filename=paste0(tmpdir,"/image_QC.pdf")
cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
pdf(filename,out.width,out.height,fillOddEven=TRUE) #fillOddEven to have polygon() filled with same rule as point.in.polygon()
par(mar=c(0.3,0,0.3,0))#same top/bottom margin as cell density


##plot image quality + sharpness
image.sharpness=data.table::dcast(data.binned,x.factor~y.factor,value.var="sharpness",fill=0,drop=FALSE)
image.sharpness=as.Image(as.matrix(image.sharpness[,-1]))
image.is.valid=data.table::dcast(data.binned,x.factor~y.factor,value.var="is.valid",fill=0,drop=FALSE)
image.is.valid=as.Image(as.matrix(image.is.valid[,-1]))
if("is.masked.low.dapi"%in%colnames(data.binned))
{
    image.is.masked.low.dapi=data.table::dcast(data.binned,x.factor~y.factor,value.var="is.masked.low.dapi",fill=0,drop=FALSE)
    image.is.masked.low.dapi=as.Image(as.matrix(image.is.masked.low.dapi[,-1]))
}
if(!"is.masked.low.dapi"%in%colnames(data.binned))##fallback if input file does not have "is.masked.low.dapi"
{
    ##
    image.is.masked.low.dapi=data.table::dcast(data.binned,x.factor~y.factor,value.var=input.dapi,fill=0,drop=FALSE)
    image.is.masked.low.dapi=as.Image(as.matrix(image.is.masked.low.dapi[,-1]))
    threshold=watershed.low.dapi
    image.is.masked.low.dapi=threshold-image.is.masked.low.dapi
    image.is.masked.low.dapi[image.is.masked.low.dapi>0]=1
    image.is.masked.low.dapi[image.is.masked.low.dapi<=0]=0
}

tmp.r=0*image.is.masked.low.dapi
tmp.g=0*image.is.masked.low.dapi
tmp.b=0*image.is.masked.low.dapi
##bad
tmp.r[image.sharpness<=sharpness.low.threshold]=1
tmp.g[image.sharpness<=sharpness.low.threshold]=0
tmp.b[image.sharpness<=sharpness.low.threshold]=0
##warning
tmp.r[image.sharpness>sharpness.low.threshold]=1
tmp.g[image.sharpness>sharpness.low.threshold]=1
tmp.b[image.sharpness>sharpness.low.threshold]=0
##good
tmp.r[image.sharpness>sharpness.high.threshold]=0
tmp.g[image.sharpness>sharpness.high.threshold]=1
tmp.b[image.sharpness>sharpness.high.threshold]=0
##low dapi
tmp.r[image.is.masked.low.dapi>0.5]=0.75
tmp.g[image.is.masked.low.dapi>0.5]=0.75
tmp.b[image.is.masked.low.dapi>0.5]=0.75
##not valid
tmp.r[image.is.valid<0.5]=1
tmp.g[image.is.valid<0.5]=1
tmp.b[image.is.valid<0.5]=1

image.quality=rgbImage(tmp.r,tmp.g,tmp.b)
plot(as.raster(image.quality[,ncol(image.quality):1,]),ylim=c(ncol(image.quality),0),interpolate=FALSE)
for(i in excluded.regions[,unique(id)])
    polygon(excluded.regions[id==i,.((x-xlevels[1])/data.binned.binsize,(y-ylevels[1])/data.binned.binsize)],border=rgb(0,0,1,0.9),col=rgb(0,0,1,0.3),lwd=2)#Note: plot(as.raster()) =>  upper left corner at (0,0)


##add scale
image.width.micron=convert.image.to.slide.length(clipped.image.width.pixel,image.info)
##we want approx 1/5 of image width
tmp=pretty(c(0,image.width.micron),n=7)
bar.width.micron=tmp[2]-tmp[1]
##convert to image coordinates (1 pixel in this image = data.binned.binsize original image pixel)
bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/data.binned.binsize
space=0.01*max(ncol(image.quality),nrow(image.quality))
lines(x=space+c(0,bar.width),y=(ncol(image.quality)-space)*c(1,1),col="black",lwd=2)
text(x=space+bar.width/2,y=ncol(image.quality)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="black",pos=3,cex=0.6,offset=0.2)

QC.bin.count=c("empty"=sum(abs(image.quality[,,1]-1)<0.0001&
                                        abs(image.quality[,,2]-1)<0.0001&
                                        abs(image.quality[,,3]-1)<0.0001),
               "low.dapi"=sum(abs(image.quality[,,1]-0.75)<0.0001&
                              abs(image.quality[,,2]-0.75)<0.0001&
                              abs(image.quality[,,3]-0.75)<0.0001),
               "bad.sharpness"=sum(abs(image.quality[,,1]-1)<0.0001&
                                   abs(image.quality[,,2]-0)<0.0001&
                                   abs(image.quality[,,3]-0)<0.0001),
               "warning.sharpness"=sum(abs(image.quality[,,1]-1)<0.0001&
                                       abs(image.quality[,,2]-1)<0.0001&
                                       abs(image.quality[,,3]-0)<0.0001),
               "ok.sharpness"=sum(abs(image.quality[,,1]-0)<0.0001&
                                  abs(image.quality[,,2]-1)<0.0001&
                                  abs(image.quality[,,3]-0)<0.0001),
               "all.bins"=nrow(image.quality)*ncol(image.quality)
               )

dev.off()

##############################
##create cell density plot 
##############################
w=clipped.image.width.pixel
h=clipped.image.height.pixel
out.size.max.inches=7
legend.size.inches=0.8
out.width=w*out.size.max.inches/max(h,w)+legend.size.inches
out.height=h*out.size.max.inches/max(h,w)

filename=paste0(tmpdir,"/image_cell_density.pdf")
cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
pdf(filename,out.width,out.height)
par(mar=c(0.3,0,0.3,0))#same top/bottom margin as cell density

## average sharpness, nucleus.radius.mean, dapi eccentricity, dapi theta
xlim=c(clip.region.binned["x.min"],clip.region.binned["x.max"])
ylim=c(clip.region.binned["y.min"],clip.region.binned["y.max"])
binsize=data.binned.binsize #pixel

##bin to image (average channel value):
image_density=data.all[selected==TRUE,.(nucleus.x,nucleus.y,cell.ID)]

setnames(image_density,c("x","y","value"))
binarea.mm2=convert.image.to.slide.area(binsize*binsize,image.info)/10**6
image_density=image_density[,.(value=.N/binarea.mm2),by=.(x=round(x/binsize)*binsize,y=round(y/binsize)*binsize)]

xlevels=round(seq(round(xlim[1]/binsize)*binsize,round(xlim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
ylevels=round(seq(round(ylim[1]/binsize)*binsize,round(ylim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
image_density[,x:=factor(x,levels=xlevels)]
image_density[,y:=factor(y,levels=ylevels)]
{
    if(nrow(image_density)>0)
    {
        image_density=data.table::dcast(image_density,x~y,value.var="value",fill=0,drop=FALSE)
        image_density=as.matrix(image_density[,-1])
        zlim=c(0,max(image_density))
    }
    else
    {
        image_density=matrix(0,nrow=length(xlevels),ncol=length(ylevels))
        zlim=c(0,1)
    }
}
##set density=0 to NA
image_density[image_density==0]=NA

plot_image(image_density,cex.main=0.6,sqrt=TRUE,zlim=zlim,show.legend=TRUE,mar=c(0.3,0,0.3,3),colors=colorRampPalette(colors.density,space="Lab")(256))

##add scale
image.width.micron=convert.image.to.slide.length(clipped.image.width.pixel,image.info)
##we want approx 1/5 of image width
tmp=pretty(c(0,image.width.micron),n=7)
bar.width.micron=tmp[2]-tmp[1]
##convert to image coordinates (1 pixel in this image = binsize original image pixel)
bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/binsize
space=0.01*max(ncol(image_density),nrow(image_density))
lines(x=space+c(0,bar.width),y=(ncol(image_density)-space)*c(1,1),col="grey30",lwd=2)
text(x=space+bar.width/2,y=ncol(image_density)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="grey30",pos=3,cex=0.6,offset=0.2)

dev.off()

##############################
## CK thresholding plot
##############################
if(tumor_marker_present)
{
    filename=paste0(tmpdir,"/automatic_ck_thresholding.pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,5,2.5)
    par(mar=0.1+c(3, 3, 0.5, 0.5),mgp=c(2,1,0))
    ##histogram + threshold
    x.transfo=function(x){sqrt(x)}
    if(nrow(data.all[selected==TRUE])==0)##empty
    {
        plot(0,0,type="n",xlab="",ylab="",xaxt="n",yaxt="n")
    }
    if(nrow(data.all[selected==TRUE])>0)
    {
        hist(unlist(x.transfo(data.all[selected==TRUE,paste0(input.ck,".score"),with=FALSE])),breaks=50,freq=TRUE,xlab=paste0(ck.channel.name," score"),cex.axis=0.8,border="grey20",col="grey95",xaxt="n",main="")
        abline(v=x.transfo(metadata.channel.thresholding[input.ck,"threshold"]),col="red",lw=2)
        ########### axis (for transfo=sqrt(x)#####
        xmin=min(data.all[selected==TRUE,paste0(input.ck,".score"),with=FALSE])
        xmax=max(data.all[selected==TRUE,paste0(input.ck,".score"),with=FALSE])
        if(xmax-xmin>1e-6)
        {
            l=ceiling(log10(xmax))
            ##major
            xlab1=(floor(xmin/10**(l-1)):ceiling(xmax/10**(l-1)))*10**(l-1)
            ##minor1
            xlab2=(xlab1[-1]+xlab1[-length(xlab1)])/2
            ##minor2
            xlab3=((min(xlab1)/10**(l-2)):(max(xlab1)/10**(l-2)))*10**(l-2)
            xlab3=xlab3[!xlab3%in%c(xlab1,xlab2)]
            ##minor2
            xlab4=((xlab1[1]/10**(l-3)):(10**(l-2)/10**(l-3)))*10**(l-3)
            xlab4=xlab4[!xlab4%in%c(xlab1,xlab2,xlab3)]
            axis(1,at=x.transfo(xlab1),labels=xlab1,tcl=-0.6,cex.axis=0.8)
            xlab=FALSE;
            if(length(xlab1)+length(xlab2)<15)xlab=xlab2
            axis(1,at=x.transfo(xlab2),labels=xlab,tcl=-0.5,cex.axis=0.8,lwd=0.5)
            xlab=FALSE;
            if(length(xlab1)+length(xlab2)+length(xlab3)<15)xlab=xlab3
            axis(1,at=x.transfo(xlab3),labels=xlab,tcl=-0.3,cex.axis=0.8,lwd=0.5)
            xlab=FALSE;
            if(length(xlab1)+length(xlab2)+length(xlab3)+length(xlab4)<15)xlab=xlab4
            axis(1,at=x.transfo(xlab4),labels=xlab,tcl=-0.1,cex.axis=0.8,lwd=0.5)
        }
    }
    dev.off()
}

##############################
##create dominant tissue type plot 
##############################
if(tumor_marker_present)
{
    w=clipped.image.width.pixel
    h=clipped.image.height.pixel
    out.size.max.inches=7
    legend.size.inches=0 #no legend
    out.width=w*out.size.max.inches/max(h,w)+legend.size.inches
    out.height=h*out.size.max.inches/max(h,w)

    filename=paste0(tmpdir,"/image_tissue_type.pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,out.width,out.height)
    par(mar=c(0.3,0,0.3,0))#same top/bottom margin as cell density

    ## average sharpness, nucleus.radius.mean, dapi eccentricity, dapi theta
    xlim=c(clip.region.binned["x.min"],clip.region.binned["x.max"])
    ylim=c(clip.region.binned["y.min"],clip.region.binned["y.max"])
    binsize=data.binned.binsize #pixel

    ##bin to image (average channel value):
    image_tissue_type=data.all[selected==TRUE,.(nucleus.x,nucleus.y,tissue.type)]
    setnames(image_tissue_type,c("x","y","value"))

    image_tissue_type=image_tissue_type[,.(.N),by=.(x=round(x/binsize)*binsize,y=round(y/binsize)*binsize,value)][,.(value=value[which.max(N)]),by=.(x,y)]


    xlevels=round(seq(round(xlim[1]/binsize)*binsize,round(xlim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
    ylevels=round(seq(round(ylim[1]/binsize)*binsize,round(ylim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
    image_tissue_type[,x:=factor(x,levels=xlevels)]
    image_tissue_type[,y:=factor(y,levels=ylevels)]
    {
        if(nrow(image_tissue_type)>0)
        {
            image_tissue_type=data.table::dcast(image_tissue_type,x~y,value.var="value",fill=NA,drop=FALSE)
            image_tissue_type=as.matrix(image_tissue_type[,-1])
        }
        else
        {
            image_tissue_type=matrix(NA,nrow=length(xlevels),ncol=length(ylevels))
        }
    }

    tissue.color=c(other="blue",stroma="green",tumor="red")
    image_tissue_type[is.na(image_tissue_type)]="white"
    for(tt in names(tissue.color))
        image_tissue_type[image_tissue_type==tt]=tissue.color[tt]

    plot(as.raster(as.Image(image_tissue_type)[,ncol(image_tissue_type):1,]),ylim=c(ncol(image_tissue_type),0),interpolate=FALSE)

    ##add scale
    image.width.micron=convert.image.to.slide.length(clipped.image.width.pixel,image.info)
    ##we want approx 1/5 of image width
    tmp=pretty(c(0,image.width.micron),n=7)
    bar.width.micron=tmp[2]-tmp[1]
    ##convert to image coordinates (1 pixel in this image = binsize original image pixel)
    bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/binsize
    space=0.01*max(ncol(image_tissue_type),nrow(image_tissue_type))
    lines(x=space+c(0,bar.width),y=(ncol(image_tissue_type)-space)*c(1,1),col="black",lwd=2)
    text(x=space+bar.width/2,y=ncol(image_tissue_type)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="black",pos=3,cex=0.6,offset=0.2)

    dev.off()
}



##############################
##create images of channel intensity
##and <channel> positive cells density
##############################
##images of channel intensity
w=clipped.image.width.pixel
h=clipped.image.height.pixel
out.size.max.inches=7
legend.size.inches=0 #no legend
out.width=w*out.size.max.inches/max(h,w)+legend.size.inches
out.height=h*out.size.max.inches/max(h,w)
for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{    
    filename=paste0(tmpdir,"/image_channel_intensity_",f,".pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,out.width,out.height)
    par(mar=c(0.3,0,0.3,0))#same top/bottom margin as cell density
    ##plot composite image (only dapi and channel f) using binned data
    xlevels=seq(0,image.info$image.width.pixel,by=data.binned.binsize)
    ylevels=seq(0,image.info$image.height.pixel,by=data.binned.binsize)
    xlevels=xlevels[xlevels>=clip.region.binned["x.min"]&xlevels<=clip.region.binned["x.max"]]
    ylevels=ylevels[ylevels>=clip.region.binned["y.min"]&ylevels<=clip.region.binned["y.max"]]

    ##eval composite image r,g,b
    channels.to.plot=c(input.dapi,f)
    color.r=as.numeric(sapply(strsplit(metadata[channels.to.plot,"color"],","),function(x){x[1]}))/255
    color.g=as.numeric(sapply(strsplit(metadata[channels.to.plot,"color"],","),function(x){x[2]}))/255
    color.b=as.numeric(sapply(strsplit(metadata[channels.to.plot,"color"],","),function(x){x[3]}))/255
    names(color.r)=channels.to.plot
    names(color.g)=channels.to.plot
    names(color.b)=channels.to.plot
    data.binned[,composite.r:=0]
    data.binned[,composite.g:=0]
    data.binned[,composite.b:=0]
    data.binned[,composite.r:=as.matrix(data.binned[,.SD,.SDcols=channels.to.plot])[,channels.to.plot]%*%(color.r[channels.to.plot]/channel.normalization[channels.to.plot])]
    data.binned[,composite.g:=as.matrix(data.binned[,.SD,.SDcols=channels.to.plot])[,channels.to.plot]%*%(color.g[channels.to.plot]/channel.normalization[channels.to.plot])]
    data.binned[,composite.b:=as.matrix(data.binned[,.SD,.SDcols=channels.to.plot])[,channels.to.plot]%*%(color.b[channels.to.plot]/channel.normalization[channels.to.plot])]

    ##normalize to 99 percentile
    data.binned[,composite.r:=composite.r/plot.global.normalization.factor]
    data.binned[,composite.g:=composite.g/plot.global.normalization.factor]
    data.binned[,composite.b:=composite.b/plot.global.normalization.factor]

    image.r=data.table::dcast(data.binned,x.factor~y.factor,value.var="composite.r",fill=0,drop=FALSE)
    image.r=as.Image(as.matrix(image.r[,-1]))

    image.g=data.table::dcast(data.binned,x.factor~y.factor,value.var="composite.g",fill=0,drop=FALSE)
    image.g=as.Image(as.matrix(image.g[,-1]))

    image.b=data.table::dcast(data.binned,x.factor~y.factor,value.var="composite.b",fill=0,drop=FALSE)
    image.b=as.Image(as.matrix(image.b[,-1]))

    image.r[image.r>1]=1
    image.g[image.g>1]=1
    image.b[image.b>1]=1
    image_composite=rgbImage(image.r,image.g,image.b)
    plot(as.raster(image_composite[,ncol(image_composite):1,]),ylim=c(ncol(image_composite),0),interpolate=FALSE)

    ##add scale
    image.width.micron=convert.image.to.slide.length(clipped.image.width.pixel,image.info)
    ##we want approx 1/5 of image width
    tmp=pretty(c(0,image.width.micron),n=7)
    bar.width.micron=tmp[2]-tmp[1]
    ##convert to image coordinates (1 pixel in this image = data.binned.binsize original image pixel)
    bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/data.binned.binsize
    space=0.01*max(ncol(image_composite),nrow(image_composite))
    lines(x=space+c(0,bar.width),y=(ncol(image_composite)-space)*c(1,1),col="white",lwd=2)
    text(x=space+bar.width/2,y=ncol(image_composite)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="white",pos=3,cex=0.6,offset=0.2)

    dev.off()
}


##create images of <channel> positive cells density
w=clipped.image.width.pixel
h=clipped.image.height.pixel
out.size.max.inches=7
legend.size.inches=0.8
out.width=w*out.size.max.inches/max(h,w)+legend.size.inches
out.height=h*out.size.max.inches/max(h,w)
for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
{
    filename=paste0(tmpdir,"/image_channel_cell_density_",f,".pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,out.width,out.height)
    par(mar=c(0,0,0,0))

    ## average sharpness, nucleus.radius.mean, dapi eccentricity, dapi theta
    xlim=c(clip.region.binned["x.min"],clip.region.binned["x.max"])
    ylim=c(clip.region.binned["y.min"],clip.region.binned["y.max"])
    binsize=data.binned.binsize #pixel

    ##bin to image (average channel value):
    image_density_tmp=setnames(data.all[selected==TRUE,c("nucleus.x","nucleus.y",paste0(f,".above.threshold")),with=FALSE],c("nucleus.x","nucleus.y","channel.above.threshold"))[channel.above.threshold==TRUE]

    setnames(image_density_tmp,c("x","y","value"))
    binarea.mm2=convert.image.to.slide.area(binsize*binsize,image.info)/10**6
    image_density_tmp=image_density_tmp[,.(value=.N/binarea.mm2),by=.(x=round(x/binsize)*binsize,y=round(y/binsize)*binsize)]

    xlevels=round(seq(round(xlim[1]/binsize)*binsize,round(xlim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
    ylevels=round(seq(round(ylim[1]/binsize)*binsize,round(ylim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
    image_density_tmp[,x:=factor(x,levels=xlevels)]
    image_density_tmp[,y:=factor(y,levels=ylevels)]
    if(nrow(image_density_tmp)>0)
    {
        image_density_tmp=data.table::dcast(image_density_tmp,x~y,value.var="value",fill=0,drop=FALSE)
        image_density_tmp=as.matrix(image_density_tmp[,-1])
        zlim=c(0,max(image_density_tmp))
    }
    else
    {
        image_density_tmp=matrix(0,nrow=length(xlevels),ncol=length(ylevels))
        zlim=c(0,1)
    }

    ##set (global) cell density to NA 
    image_density_tmp[is.na(image_density)]=NA

    plot_image(image_density_tmp,cex.main=0.6,sqrt=TRUE,zlim=zlim,show.legend=TRUE,mar=c(0.3,0,0.3,3),colors=colorRampPalette(colors.density,space="Lab")(256))
    
    ##add scale
    image.width.micron=convert.image.to.slide.length(clipped.image.width.pixel,image.info)
    ##we want approx 1/5 of image width
    tmp=pretty(c(0,image.width.micron),n=7)
    bar.width.micron=tmp[2]-tmp[1]
    ##convert to image coordinates (1 pixel in this image = binsize original image pixel)
    bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/binsize
    space=0.01*max(ncol(image_density_tmp),nrow(image_density_tmp))
    lines(x=space+c(0,bar.width),y=(ncol(image_density_tmp)-space)*c(1,1),col="grey30",lwd=2)
    text(x=space+bar.width/2,y=ncol(image_density_tmp)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="grey30",pos=3,cex=0.6,offset=0.2)
    
    dev.off()
}

##############################
##create image of cells density per phenotype
##############################

w=clipped.image.width.pixel
h=clipped.image.height.pixel
out.size.max.inches=7
legend.size.inches=0.8
out.width=w*out.size.max.inches/max(h,w)+legend.size.inches
out.height=h*out.size.max.inches/max(h,w)
for(i in seq_along(phenotypes.list))
{
    phenotype.raw.tmp=phenotypes.raw.to.label[gsub("^other.*","other",label)==phenotypes.list[i],raw]

    ## average sharpness, nucleus.radius.mean, dapi eccentricity, dapi theta
    xlim=c(clip.region.binned["x.min"],clip.region.binned["x.max"])
    ylim=c(clip.region.binned["y.min"],clip.region.binned["y.max"])
    binsize=data.binned.binsize #pixel

    ##bin to image (average channel value):
    image_density_tmp=data.all[selected==TRUE&phenotype.raw%in%phenotype.raw.tmp,.(nucleus.x,nucleus.y,phenotype.raw)]

    setnames(image_density_tmp,c("x","y","value"))
    binarea.mm2=convert.image.to.slide.area(binsize*binsize,image.info)/10**6
    image_density_tmp=image_density_tmp[,.(value=.N/binarea.mm2),by=.(x=round(x/binsize)*binsize,y=round(y/binsize)*binsize)]

    xlevels=round(seq(round(xlim[1]/binsize)*binsize,round(xlim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
    ylevels=round(seq(round(ylim[1]/binsize)*binsize,round(ylim[2]/binsize)*binsize+0.1*binsize,by=binsize)/binsize)*binsize
    image_density_tmp[,x:=factor(x,levels=xlevels)]
    image_density_tmp[,y:=factor(y,levels=ylevels)]
    if(nrow(image_density_tmp)>0)
    {
        image_density_tmp=data.table::dcast(image_density_tmp,x~y,value.var="value",fill=0,drop=FALSE)
        image_density_tmp=as.matrix(image_density_tmp[,-1])
        zlim=c(0,max(image_density_tmp))
    }
    else
    {
        image_density_tmp=matrix(0,nrow=length(xlevels),ncol=length(ylevels))
        zlim=c(0,1)
    }
        
    ##set (global) cell density to NA 
    image_density_tmp[is.na(image_density)]=NA

    filename=paste0(tmpdir,"/image_cell_density_phenotype_",i,".pdf")
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,out.width,out.height)
    par(mar=c(0,0,0,0))

    plot_image(image_density_tmp,cex.main=0.6,sqrt=TRUE,zlim=zlim,show.legend=TRUE,mar=c(0.3,0,0.3,3),colors=colorRampPalette(colors.density,space="Lab")(256))
    
    ##add scale
    image.width.micron=convert.image.to.slide.length(clipped.image.width.pixel,image.info)
    ##we want approx 1/5 of image width
    tmp=pretty(c(0,image.width.micron),n=7)
    bar.width.micron=tmp[2]-tmp[1]
    ##convert to image coordinates (1 pixel in this image = binsize original image pixel)
    bar.width=convert.slide.to.image.length(bar.width.micron,image.info)/binsize
    space=0.01*max(ncol(image_density_tmp),nrow(image_density_tmp))
    lines(x=space+c(0,bar.width),y=(ncol(image_density_tmp)-space)*c(1,1),col="grey30",lwd=2)
    text(x=space+bar.width/2,y=ncol(image_density_tmp)-space,label=bquote(.(bar.width.micron) ~ mu*"m"),col="grey30",pos=3,cex=0.6,offset=0.2)
    
    dev.off()
}



######################################
###functions to return summarizing tables
#######################################

##return unformated table
get_ROI_summary_table=function()
{    
    data.ROI.summary=data.frame(ID=seq_along(regions.of.interest.labels),label=regions.of.interest.labels,area=NA,stringsAsFactors=FALSE)
    for(i in seq_along(regions.of.interest.labels))
    {
        ##area in mm^2
        data.ROI.summary[i,"area"]=convert.image.to.slide.area(get_region_area(i),image.info)/1e6
    }
    if(tumor_tissue_only.ROI.tokeep%in%regions.of.interest.labels)
    {
        ##add Tumor tissue only
        if(any(tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels))
        {
            data.ROI.summary=rbind(data.ROI.summary,
                                   data.frame(ID=paste0(match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels),"-",paste(match(tumor_tissue_only.ROI.toremove[tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels],regions.of.interest.labels),collapse="-")),
                                              label=paste0(tumor_tissue_only.ROI.tokeep," only"),
                                              area=convert.image.to.slide.area(get_region_area(-1),image.info)/1e6))
        }
        else
        {
            data.ROI.summary=rbind(data.ROI.summary,
                                   data.frame(ID=match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels),
                                              label=paste0(tumor_tissue_only.ROI.tokeep," only"),
                                              area=convert.image.to.slide.area(get_region_area(-1),image.info)/1e6))
        }
    }
    return(data.ROI.summary)
}

##return formated table
get_formated_ROI_summary_table=function()
{
    data.ROI.summary=get_ROI_summary_table()
    data.ROI.summary$label=str_sanitize_latex(data.ROI.summary$label)
    data.ROI.summary$area=signif(data.ROI.summary$area,4)
    colnames(data.ROI.summary)=gsub("^area$","Area (mm$^2$)",colnames(data.ROI.summary))
    colnames(data.ROI.summary)=gsub("^label$","Label",colnames(data.ROI.summary))
    
    return(data.ROI.summary)
}


##return unformated table
##roi.label.idx=NULL => everything
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
get_tissue_type_summary_table=function(roi.label.idx=NULL)
{    
    if(is.null(roi.label.idx))
    {
        data.all[,selected.tmp:=(!excluded)]
    }
    else if(length(roi.label.idx)==1&&roi.label.idx==-1)
    {
        data.all[,selected.tmp:=in.ROI._tumor_tissue_only_]
        data.all[excluded==TRUE,selected.tmp:=FALSE]
    }
    else
    {
        data.all$selected.tmp=FALSE
        for(i in roi.label.idx)
            data.all$selected.tmp=data.all$selected.tmp|data.all[,.SD,.SDcols=paste0("in.ROI.",i)]       
        data.all[excluded==TRUE,selected.tmp:=FALSE]
    }

    ##area in mm^2
    data.tissue.type.summary=data.all[selected.tmp==TRUE,.(tissue.type,area=convert.image.to.slide.area(area,image.info)/1e6)][,.(area=sum(area),count=.N),by=.(tissue.type)]
    ##add missing tissue type
    data.tissue.type.summary=data.tissue.type.summary[data.table(tissue.type=tissue.type.list),on=.(tissue.type)][,.(tissue.type,area=ifelse(is.na(area),0,area),count=ifelse(is.na(count),0,count))]
    ##add percent
    data.tissue.type.summary[,area.percent:=100*area/sum(area)]
    data.tissue.type.summary[,count.percent:=100*count/sum(count)]
    ##add total
    data.tissue.type.summary=rbind(data.tissue.type.summary,data.table(tissue.type="Total",data.tissue.type.summary[,.(area=sum(area),count=sum(count),area.percent=sum(area.percent),count.percent=sum(count.percent))]))
    ##add density
    data.tissue.type.summary[,density:=count/area]
    data.tissue.type.summary[,density:=round(density,digits=pmax(0,-floor(log10(1/area))))]
    data.tissue.type.summary[count==0,density:=0]

    data.all[,selected.tmp:=NULL]
    
    return(data.frame(data.tissue.type.summary,check.names=FALSE,stringsAsFactors=FALSE))
}

##return formated table
##roi.label.idx=NULL => everything
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
get_formated_tissue_type_summary_table=function(roi.label.idx=NULL)
{
    data.tissue.type.summary=get_tissue_type_summary_table(roi.label.idx)
    data.tissue.type.summary$area=signif(data.tissue.type.summary$area,4)
    data.tissue.type.summary$area.percent=paste0(signif(data.tissue.type.summary$area.percent,3),"\\%")
    data.tissue.type.summary$count.percent=paste0(signif(data.tissue.type.summary$count.percent,3),"\\%")
    data.tissue.type.summary[,"tissue.type"]=sapply(data.tissue.type.summary[,"tissue.type"],function(x){substr(x, 1, 1) <- toupper(substr(x, 1, 1));x})
    rownames(data.tissue.type.summary)=data.tissue.type.summary[,"tissue.type"]
    data.tissue.type.summary=data.tissue.type.summary[,c("tissue.type","area","area.percent","count","count.percent","density")]
    colnames(data.tissue.type.summary)=gsub("^area$","Area (mm$^2$)",colnames(data.tissue.type.summary))
    colnames(data.tissue.type.summary)=gsub("^area.percent$","Area (\\\\%)",colnames(data.tissue.type.summary))
    colnames(data.tissue.type.summary)=gsub("^count$","Number of cells",colnames(data.tissue.type.summary))
    colnames(data.tissue.type.summary)=gsub("^count.percent$","Number of cells (\\\\%)",colnames(data.tissue.type.summary))
    colnames(data.tissue.type.summary)=gsub("^density","Density (cells/mm$^2$)",colnames(data.tissue.type.summary))
    colnames(data.tissue.type.summary)=gsub("^tissue.type$","Tissue",colnames(data.tissue.type.summary))
    if(flag_other_tissue)
    {
        data.tissue.type.summary=data.tissue.type.summary[c("Stroma","Tumor","Other","Total"),]
    }
    else
    {
        data.tissue.type.summary=data.tissue.type.summary[c("Stroma","Tumor","Total"),]
    }
    data.tissue.type.summary["Total",]=paste0("\\textbf{",data.tissue.type.summary["Total",],"}")
    
    return(data.tissue.type.summary)
}



##return unformated table
##tissue.type=c("total","stroma","tumor")
##roi.label.idx=NULL => everything
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
get_single_marker_summary_table=function(tissue.type,roi.label.idx=NULL)
{    
    if(is.null(roi.label.idx))
    {
        data.all[,selected.tmp:=(!excluded)]
    }
    else if(length(roi.label.idx)==1&&roi.label.idx==-1)
    {
        data.all[,selected.tmp:=in.ROI._tumor_tissue_only_]
        data.all[excluded==TRUE,selected.tmp:=FALSE]
    }
    else
    {
        data.all$selected.tmp=FALSE
        for(i in roi.label.idx)
            data.all$selected.tmp=data.all$selected.tmp|data.all[,.SD,.SDcols=paste0("in.ROI.",i)]
        data.all[excluded==TRUE,selected.tmp:=FALSE]
    }

    cols=rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)]
    single.marker.count.summary=rbindlist(lapply(cols,function(f){
        channel.name=metadata[f,"name"]
        tmp=setnames(data.all[selected.tmp==TRUE,c(paste0(f,".above.threshold"),"tissue.type","area"),with=FALSE],c("channel.above.threshold","tissue.type","area"))[channel.above.threshold==TRUE,.(marker=channel.name,count=.N,area=sum(convert.image.to.slide.area(area,image.info)/1e6)),by=.(tissue.type)]
        if(nrow(tmp)==0)
            tmp=data.table(tissue.type=tissue.type.list,marker=channel.name,count=0,area=0)
        tmp
    }))
    single.marker.count.summary=rbind(single.marker.count.summary,
                                      data.all[selected.tmp==TRUE,.(marker="All",count=.N,area=sum(convert.image.to.slide.area(area,image.info)/1e6)),by=.(tissue.type)])
    ##add missing marker / tissue.type combination
    single.marker.count.summary=single.marker.count.summary[CJ(marker=c(metadata[cols,"name"],"All"),tissue.type=tissue.type.list,sorted=FALSE),on=.(marker,tissue.type)][,.(marker,tissue.type,count=ifelse(is.na(count),0,count),area=ifelse(is.na(area),0,area))]
    ##remove column
    data.all[,selected.tmp:=NULL]

    if(tissue.type=="total")
    {        
        single.marker.count.summary=data.frame(single.marker.count.summary[,.(count=sum(count),area=sum(area)),by=marker],check.names=FALSE,stringsAsFactors=FALSE)
    }
    else
    {
        tt=tissue.type
        single.marker.count.summary=data.frame(single.marker.count.summary[tissue.type==tt,.(count=sum(count),area=sum(area)),by=marker],check.names=FALSE,stringsAsFactors=FALSE)
    }
    rownames(single.marker.count.summary)=single.marker.count.summary$marker
    single.marker.count.summary$marker=gsub("All-positive","All",paste0(single.marker.count.summary$marker,"-positive cells"))
    totalarea=single.marker.count.summary["All","area"]
    ##add percents
    single.marker.count.summary$count.percent=100*single.marker.count.summary$count/single.marker.count.summary["All","count"]
    single.marker.count.summary$area.percent=100*single.marker.count.summary$area/single.marker.count.summary["All","area"]
    single.marker.count.summary[single.marker.count.summary$count==0,"count.percent"]=0
    single.marker.count.summary[single.marker.count.summary$area==0,"area.percent"]=0
    ##add density
    single.marker.count.summary$density=single.marker.count.summary$count/totalarea
    single.marker.count.summary$density=round(single.marker.count.summary$density,digits=-floor(log10(1/totalarea)))
    single.marker.count.summary[single.marker.count.summary$count==0,"density"]=0
    return(single.marker.count.summary)
}

##return formated table
##tissue.type=c("total","stroma","tumor")
##roi.label.idx=NULL => everything
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
get_formated_single_marker_summary_table=function(tissue.type,roi.label.idx=NULL)
{
    single.marker.count.summary=get_single_marker_summary_table(tissue.type,roi.label.idx)
    ##Format
    single.marker.count.summary$area=signif(single.marker.count.summary$area,4)
    single.marker.count.summary$area.percent=paste0(signif(single.marker.count.summary$area.percent,2),"\\%")
    single.marker.count.summary$count.percent=paste0(signif(single.marker.count.summary$count.percent,2),"\\%")
    ##keep only relevant columns
    single.marker.count.summary=single.marker.count.summary[,c("marker","count","count.percent","area","area.percent","density")]
    colnames(single.marker.count.summary)=c("Population","Number of cells","Number of cells (\\%)","Area (mm$^2$)","Area (\\%)","Density (cells/mm$^2$)") #,"Area (mm$^2$)","Area (\\%)"
    ##row Total in bold
    single.marker.count.summary["All",]=paste0("\\textbf{",single.marker.count.summary["All",],"}")
    return(single.marker.count.summary)
}



##return unformated table
##tissue.type=c("total","all","stroma","tumor")
##phentotypes.type=c("standard","other") ##"standard" => collapse all phenotypes "other *" to one entry "other", "other" => return details on "other*" phenotypes
##roi.label.idx=NULL => everything
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
get_phenotypes_summary_table=function(tissue.type,phenotypes.type,roi.label.idx=NULL)
{    
    if(is.null(roi.label.idx))
    {
        data.all[,selected.tmp:=(!excluded)]
    }
    else if(length(roi.label.idx)==1&&roi.label.idx==-1)
    {
        data.all[,selected.tmp:=in.ROI._tumor_tissue_only_]
        data.all[excluded==TRUE,selected.tmp:=FALSE]
    }
    else
    {
        data.all$selected.tmp=FALSE
        for(i in roi.label.idx)
            data.all$selected.tmp=data.all$selected.tmp|data.all[,.SD,.SDcols=paste0("in.ROI.",i)]       
        data.all[excluded==TRUE,selected.tmp:=FALSE]
        
    }


    phenotypes.raw.to.label.tmp=copy(phenotypes.raw.to.label)
    if(phenotypes.type=="standard")
    {
        phenotypes.raw.to.label.tmp[,label:=gsub("^other.*","other",label)]
        phenotypes.raw.to.label.tmp=unique(phenotypes.raw.to.label.tmp)
    }
    data.phenotypes.summary=rbindlist(lapply(phenotypes.raw.to.label.tmp[,unique(label)],function(phenotype.label){
        phenotype.raw.tmp=phenotypes.raw.to.label.tmp[label==phenotype.label,raw]
        data.all[selected.tmp==TRUE&phenotype.raw%in%phenotype.raw.tmp,.(phenotype.label,count=.N,area=sum(convert.image.to.slide.area(area,image.info)/1e6)),by=.(tissue.type)]
    }))

    ##add missing
    data.phenotypes.summary=merge(data.phenotypes.summary,CJ(tissue.type=tissue.type.list,phenotype.label=unique(c(phenotypes$label,data.phenotypes.summary$phenotype.label))),by=c("tissue.type","phenotype.label"),all=TRUE)[,.(phenotype.label,tissue.type,count=ifelse(is.na(count),0,count),area=ifelse(is.na(area),0,area))]
    if(!tissue.type%in%c("total","all"))
    {        
        tt=tissue.type
        data.phenotypes.summary=data.phenotypes.summary[tissue.type==tt]
    }
    if(tissue.type=="all")
    {
        data.phenotypes.summary=data.frame(data.phenotypes.summary[,.(count=sum(count),area=sum(area)),by=.(phenotype.label,tissue.type)],check.names=FALSE,stringsAsFactors=FALSE)
    }
    else
    {
        data.phenotypes.summary=data.frame(data.phenotypes.summary[,.(count=sum(count),area=sum(area)),by=phenotype.label],check.names=FALSE,stringsAsFactors=FALSE)
    }
    

    if(tissue.type=="total")
    {        
        totalarea=data.all[selected.tmp==TRUE,sum(convert.image.to.slide.area(area,image.info)/1e6)]
        totalcount=data.all[selected.tmp==TRUE,.N]
    }
    else if(tissue.type=="all")
    {
        totalarea=data.all[selected.tmp==TRUE,sum(convert.image.to.slide.area(area,image.info)/1e6)]
        totalcount=data.all[selected.tmp==TRUE,.N]
    }
    else
    {
        tt=tissue.type
        totalarea=data.all[selected.tmp==TRUE&tissue.type==tt,sum(convert.image.to.slide.area(area,image.info)/1e6)]
        totalcount=data.all[selected.tmp==TRUE&tissue.type==tt,.N]
    }
    ##remove column
    data.all[,selected.tmp:=NULL]
    ##add percents
    data.phenotypes.summary$count.percent=100*data.phenotypes.summary$count/totalcount
    data.phenotypes.summary$area.percent=100*data.phenotypes.summary$area/totalarea
    data.phenotypes.summary[data.phenotypes.summary$count==0,"count.percent"]=0
    data.phenotypes.summary[data.phenotypes.summary$area==0,"area.percent"]=0
    ##order by phenotype type and count
    data.phenotypes.summary=data.phenotypes.summary[order(grepl("^other",data.phenotypes.summary$phenotype.label),-data.phenotypes.summary$count,data.phenotypes.summary$phenotype.label),]
    ##add density
    data.phenotypes.summary$density=data.phenotypes.summary$count/totalarea
    data.phenotypes.summary[data.phenotypes.summary$count==0,"density"]=0
    if(phenotypes.type=="other")
    {
        ##order by phenotype type and count
        data.phenotypes.summary=data.phenotypes.summary[order(grepl("^other",data.phenotypes.summary$phenotype.label),-data.phenotypes.summary$count,data.phenotypes.summary$phenotype.label),] 
        ##keep only "other" 
        data.phenotypes.summary=data.phenotypes.summary[grepl("^other",data.phenotypes.summary$phenotype.label),]
    }
    ##add total
    if(tissue.type=="all")
    {
        data.phenotypes.summary=rbind(data.phenotypes.summary,data.frame(phenotype.label="Total",tissue.type="all",t(colSums(data.phenotypes.summary[,-(1:2)])),check.names=FALSE,stringsAsFactors=FALSE))
    }
    else
    {
        data.phenotypes.summary=rbind(data.phenotypes.summary,data.frame(phenotype.label="Total",t(colSums(data.phenotypes.summary[,-1])),check.names=FALSE,stringsAsFactors=FALSE))
    }
    ##round density
    data.phenotypes.summary$density=round(data.phenotypes.summary$density,digits=-floor(log10(1/totalarea)))

    return(data.phenotypes.summary)
}

##return formated table
##tissue.type=c("total","stroma","tumor")
##phentotypes.type=c("standard","other") ##"standard" => collapse all phenotypes "other *" to one entry "other", "other" => return details on "other*" phenotypes
##roi.label.idx=NULL => everything
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
get_formated_phenotypes_summary_table=function(tissue.type,phenotypes.type,roi.label.idx=NULL)
{    
    data.phenotypes.summary=get_phenotypes_summary_table(tissue.type,phenotypes.type,roi.label.idx)
    ##Format
    data.phenotypes.summary$area=signif(data.phenotypes.summary$area,4)
    data.phenotypes.summary$area.percent=paste0(signif(data.phenotypes.summary$area.percent,2),"\\%")
    data.phenotypes.summary$count.percent=paste0(signif(data.phenotypes.summary$count.percent,2),"\\%")
    ##escape phenotype label (to avoid special latex characters)
    data.phenotypes.summary$phenotype.label=str_sanitize_latex(data.phenotypes.summary$phenotype.label)
    ##replace "-" by "--" in phenotype.label
    data.phenotypes.summary$phenotype.label=gsub("(-|\\+)","$\\1$",data.phenotypes.summary$phenotype.label)
    ##keep only relevant columns
    if(phenotypes.type=="standard")
    {
        data.phenotypes.summary=data.phenotypes.summary[,c("phenotype.label","count","count.percent","area","area.percent","density")]
        colnames(data.phenotypes.summary)=c("Phenotype","Number of cells","Number of cells (\\%)","Area (mm$^2$)","Area (\\%)","Density (cells/mm$^2$)") #,"Area (mm$^2$)","Area (\\%)"
    }
    if(phenotypes.type=="other")
    {
        data.phenotypes.summary=data.phenotypes.summary[,c("phenotype.label","count","count.percent","density")]
        colnames(data.phenotypes.summary)=c("Phenotype","Number of cells","Number of cells (\\%)","Density (cells/mm$^2$)") #,"Area (mm$^2$)","Area (\\%)"
    }
    ##row Total in bold
    data.phenotypes.summary[data.phenotypes.summary$Phenotype=="Total",]=paste0("\\textbf{",data.phenotypes.summary[data.phenotypes.summary$Phenotype=="Total",],"}")
    ##rows "other" in grey
    data.phenotypes.summary[grep("^other",data.phenotypes.summary$Phenotype),]=apply(data.phenotypes.summary[grep("^other",data.phenotypes.summary$Phenotype),],2,function(x){paste0("\\textcolor{gray}{",x,"}")})
    return(data.phenotypes.summary)
}



##plot (in current plotting device) the phenotype summary counts
##roi.label.idx=NULL => everything
##roi.label.idx vector of integer (subset of seq_along(regions.of.interest.labels)) => ROIs with labels regions.of.interest.labels[roi.label.idx]. If roi.label.idx=-1, consider "Tumor tissue" only (i.e. ROI tumor_tissue_only.ROI.tokeep without ROIs in tumor_tissue_only.ROI.toremove)
plot_phenotypes_summary=function(roi.label.idx=NULL)
{
    tmptable=data.table(get_phenotypes_summary_table(tissue.type="total",phenotypes.type="standard",roi.label.idx))[,.(tissue.type="Total",phenotype.label,count,count.fraction=count.percent/100)]
    if(tumor_marker_present)
    {
        tmptable=rbind(tmptable,
                       data.table(get_phenotypes_summary_table(tissue.type="tumor",phenotypes.type="standard",roi.label.idx))[,.(tissue.type="Tumor",phenotype.label,count,count.fraction=count.percent/100)],
                       data.table(get_phenotypes_summary_table(tissue.type="stroma",phenotypes.type="standard",roi.label.idx))[,.(tissue.type="Stroma",phenotype.label,count,count.fraction=count.percent/100)])
        if(flag_other_tissue)
            tmptable=rbind(tmptable,data.table(get_phenotypes_summary_table(tissue.type="other",phenotypes.type="standard",roi.label.idx))[,.(tissue.type="Other",phenotype.label,count,count.fraction=count.percent/100)])
    }
        
    ##remove row "Total"
    tmptable=tmptable[phenotype.label!="Total"]

    phenotypes.list.tmp=tmptable[,.(count=sum(count)),by=phenotype.label][data.table(phenotype.label=unique(c(phenotypes$label,"other"))),on="phenotype.label"][order(phenotype.label=="other",-count,phenotype.label,na.last=TRUE)][,phenotype.label]

    tmptable$phenotype.label=factor(tmptable$phenotype.label,levels=phenotypes.list.tmp)
    if(tumor_marker_present==FALSE)
    {
        tmptable$tissue.type=factor(tmptable$tissue.type,levels=c("Total"))
    }
    else if(flag_other_tissue)
    {
        tmptable$tissue.type=factor(tmptable$tissue.type,levels=c("Total","Stroma","Tumor","Other"))
    }
    else
    {
        tmptable$tissue.type=factor(tmptable$tissue.type,levels=c("Total","Stroma","Tumor"))
    }        
    p=ggplot(aes(x=tissue.type,y=count.fraction,fill=phenotype.label),data=tmptable)
    p=p+geom_bar(position="stack",stat="identity")
    p=p+scale_y_continuous(labels = scales::percent,expand=c(0,0))
    p=p+scale_fill_manual("Phenotype",values = phenotypes.colors,drop=FALSE)
    p=p+xlab("")
    p=p+ylab("Number of cells (% of all tissue cells)")
    p=p+theme_linedraw()+theme(panel.grid=element_line(color="grey92"))
    print(p)

}


##create phenotypes summary bar plots
roi.label.idx.list=c(0,seq_along(regions.of.interest.labels))
if(length(regions.of.interest.labels)>1)roi.label.idx.list=c(roi.label.idx.list,list(seq_along(regions.of.interest.labels)))
if(tumor_tissue_only.ROI.tokeep%in%regions.of.interest.labels)roi.label.idx.list=c(roi.label.idx.list,-1)
for(roi.label.idx in roi.label.idx.list)
{
    if(length(roi.label.idx)==1&&roi.label.idx==0)
    {
        filename=paste0(tmpdir,"/phenotypes_cell_count.pdf")
    }
    else
    {
        filename=paste0(tmpdir,"/phenotypes_cell_count_roi_",paste(roi.label.idx,collapse="_"),".pdf")
    }
    cat(paste0("[",format(Sys.time()),"] "),"creating",filename,"\n")
    pdf(filename,9,5)
    if(length(roi.label.idx)==1&&roi.label.idx==0)
    {
        plot_phenotypes_summary(roi.label.idx=NULL)
    }
    else
    {
        plot_phenotypes_summary(roi.label.idx)
    }
    dev.off()
}



##############################
##generate report
##############################
cat(paste0("[",format(Sys.time()),"] "),"rendering report\n")
dir.create(outputdir,showWarnings=FALSE,recursive=TRUE)

##rmarkdown creates files into dirname(input.rmarkdown). To avoid this, we first copy input.rmarkdown to the destination directory
input.rmarkdown.tmp=paste0(outputdir,basename(input.rmarkdown))
file.copy(input.rmarkdown, input.rmarkdown.tmp, overwrite = TRUE)
rmarkdown.path=normalizePath(dirname(input.rmarkdown))
rmarkdown::render(input.rmarkdown.tmp,output_dir=outputdir)
file.remove(input.rmarkdown.tmp)


##############################
##save summary table
##############################
if(flag_tables)
{
    roi.label.idx.list=c(0,seq_along(regions.of.interest.labels))
    if(length(regions.of.interest.labels)>1)roi.label.idx.list=c(roi.label.idx.list,list(seq_along(regions.of.interest.labels)))
    if(tumor_tissue_only.ROI.tokeep%in%regions.of.interest.labels)roi.label.idx.list=c(roi.label.idx.list,-1)    
    for(i in roi.label.idx.list)
    {
        if(length(i)==1&&i==0)
        {
            filename=paste0(outputdir,"/summary_all.xlsx")
            roi.label.idx=NULL
        }
        else if(length(i)==1&&i==-1)
        {
            filename=paste0(outputdir,"/summary_ROI_tumor_tissue_only.xlsx")
            roi.label.idx=i
        }
        else
        {
            filename=paste0(outputdir,"/summary_ROI_",paste(i,collapse="_"),".xlsx")
            roi.label.idx=i
        }

        ##sample info
        output.table.sample.info=sample.info
        output.table.sample.info[,1]=gsub(":*$",":",output.table.sample.info[,1])
        colnames(output.table.sample.info)=NULL
        if(length(i)==1&&i==0)
        {
            ##nothing to do
        }
        else if(length(i)==1&&i==-1)
        {
            if(any(tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels))
            {
                output.table.sample.info=rbind(output.table.sample.info,
                                               c("ROI id:",paste0(match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels),"-",paste(match(tumor_tissue_only.ROI.toremove[tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels],regions.of.interest.labels),collapse="-"))),
                                               c("ROI labels:",paste0(tumor_tissue_only.ROI.tokeep," only (",tumor_tissue_only.ROI.tokeep," without ",paste(tumor_tissue_only.ROI.toremove[tumor_tissue_only.ROI.toremove%in%regions.of.interest.labels],collapse=", "),")")),
                                               c("ROI area (mm^2):",convert.image.to.slide.area(get_region_area(i),image.info)/1e6))
            }
            else
            {
                output.table.sample.info=rbind(output.table.sample.info,
                                               c("ROI id:",match(tumor_tissue_only.ROI.tokeep,regions.of.interest.labels)),
                                               c("ROI labels:",paste0(tumor_tissue_only.ROI.tokeep," only (",tumor_tissue_only.ROI.tokeep,")")),
                                               c("ROI area (mm^2):",convert.image.to.slide.area(get_region_area(i),image.info)/1e6))
            }
                
        }
        else
        {
            output.table.sample.info=rbind(output.table.sample.info,
                                           c("ROI id:",paste(i,collapse="&")),
                                           c("ROI labels:",paste(regions.of.interest.labels[i],collapse="&")),
                                           c("ROI area (mm^2):",convert.image.to.slide.area(get_region_area(i),image.info)/1e6))            
        }

        ##panel
        output.table.panel=data.frame(Channel=metadata$channel,Filter=metadata$filter,Marker=metadata$name,check.names=FALSE,stringsAsFactors=FALSE)
        tmptable=metadata.channel.thresholding[,]
        tmptable$score.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",tmptable$score.type)
        tmptable$score.statistics=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",tmptable$score.type)
        ##reformat score.region
        tmptable$score.region=gsub("^nucleus$","nucleus",tmptable$score.region)
        tmptable$score.region=gsub("^extended.nucleus$","extended nucleus",tmptable$score.region)
        tmptable$score.region=gsub("^around.nucleus$","around nucleus (doughnut)",tmptable$score.region)
        ##reformat score.statistics
        tmptable$score.statistics=gsub("circular\\.","encircling ",tmptable$score.statistics)
        tmptable$score.statistics=gsub("q050","median",tmptable$score.statistics)
        tmptable$score.statistics=gsub("q0*([1-9][0-9]*)","\\1 percentile",tmptable$score.statistics)
        tmptable$score.statistics=gsub("(^1| 1) ","\\1-st ",tmptable$score.statistics)
        tmptable$score.statistics=gsub("(^2| 2) ","\\1-nd ",tmptable$score.statistics)
        tmptable$score.statistics=gsub("([0-9]| [0-9]) ","\\1-th ",tmptable$score.statistics)
        tmptable[input.dapi,c("score.statistics","score.region","threshold")]=NA
        tmptable[input.autofluorescence,c("score.statistics","score.region","threshold")]=NA
        tmptable=tmptable[,c("score.statistics","score.region","threshold")]
        colnames(tmptable)=c("Score statistics","Score region","Threshold")
        output.table.panel=cbind(output.table.panel,tmptable[rownames(metadata),])
        
        ##phenotypes
        output.table.phenotypes=unique(data.table(phenotypes))
        for(col in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
        {
        output.table.phenotypes=setnames(output.table.phenotypes[,.(new_col=gsub("^01$","*",paste0(sort(unlist(.SD)),collapse=""))),by=c("label",cols[cols!=col]),.SDcols=col],"new_col",col)
        }
        output.table.phenotypes=output.table.phenotypes[,lapply(.SD,function(x){gsub("^1$","+",gsub("^0$","-",x))}),by=label]
        ##change colnames to marker names
        colnames(output.table.phenotypes)=ifelse(colnames(output.table.phenotypes)%in%rownames(metadata),metadata[colnames(output.table.phenotypes),"name"],colnames(output.table.phenotypes))
        setnames(output.table.phenotypes,"label","Phenotype")

        ##tissue segmentation
        output.table.tissue.segmentation=get_tissue_type_summary_table(roi.label.idx=roi.label.idx)[,c("tissue.type","count","count.percent","area","area.percent","density")]
        if(tumor_marker_present==FALSE&&flag_other_tissue==FALSE)
            output.table.tissue.segmentation=output.table.tissue.segmentation[output.table.tissue.segmentation$tissue.type!="other",]
        output.table.tissue.segmentation$tissue.type=sapply(output.table.tissue.segmentation$tissue.type,function(x){substr(x, 1, 1) <- toupper(substr(x, 1, 1));x})
        colnames(output.table.tissue.segmentation)=c("Tissue","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")

        ##single marker thresholding (total)
        output.table.single.marker.total=get_single_marker_summary_table(tissue.type="total",roi.label.idx=roi.label.idx)[,c("marker","count","count.percent","area","area.percent","density")]
        colnames(output.table.single.marker.total)=c("Marker","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        ##single marker thresholding (stroma)
        output.table.single.marker.stroma=get_single_marker_summary_table(tissue.type="stroma",roi.label.idx=roi.label.idx)[,c("marker","count","count.percent","area","area.percent","density")]
        colnames(output.table.single.marker.stroma)=c("Marker","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        ##single marker thresholding (tumor)
        output.table.single.marker.tumor=get_single_marker_summary_table(tissue.type="tumor",roi.label.idx=roi.label.idx)[,c("marker","count","count.percent","area","area.percent","density")]
        colnames(output.table.single.marker.tumor)=c("Marker","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        if(flag_other_tissue)
        {
            ##single marker thresholding (other)
            output.table.single.marker.other=get_single_marker_summary_table(tissue.type="other",roi.label.idx=roi.label.idx)[,c("marker","count","count.percent","area","area.percent","density")]
            colnames(output.table.single.marker.other)=c("Marker","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        }

        ##phenotypes (total)
        output.table.phenotypes.total=get_phenotypes_summary_table(tissue.type="total",phenotypes.type="standard",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
        colnames(output.table.phenotypes.total)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        ##phenotypes (stroma)
        output.table.phenotypes.stroma=get_phenotypes_summary_table(tissue.type="stroma",phenotypes.type="standard",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
        colnames(output.table.phenotypes.stroma)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        ##phenotypes (tumor)
        output.table.phenotypes.tumor=get_phenotypes_summary_table(tissue.type="tumor",phenotypes.type="standard",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
        colnames(output.table.phenotypes.tumor)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        if(flag_other_tissue)
        {
            ##phenotypes (other)
            output.table.phenotypes.other=get_phenotypes_summary_table(tissue.type="other",phenotypes.type="standard",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
            colnames(output.table.phenotypes.other)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        }

        ##phenotypes (total, other)
        output.table.other.phenotypes.total=get_phenotypes_summary_table(tissue.type="total",phenotypes.type="other",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
        colnames(output.table.other.phenotypes.total)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        ##phenotypes (stroma, other)
        output.table.other.phenotypes.stroma=get_phenotypes_summary_table(tissue.type="stroma",phenotypes.type="other",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
        colnames(output.table.other.phenotypes.stroma)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        ##phenotypes (tumor, other)
        output.table.other.phenotypes.tumor=get_phenotypes_summary_table(tissue.type="tumor",phenotypes.type="other",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
        colnames(output.table.other.phenotypes.tumor)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        if(flag_other_tissue)
        {
            ##phenotypes (other, other)
            output.table.other.phenotypes.other=get_phenotypes_summary_table(tissue.type="other",phenotypes.type="other",roi.label.idx=roi.label.idx)[,c("phenotype.label","count","count.percent","area","area.percent","density")]
            colnames(output.table.other.phenotypes.other)=c("Phenotype","Number of cells","Number of cells (%)","Area (mm^2)","Area (%)","Density (cells/mm^2)")
        }

        cat("creating",filename,"\n")
        if(tumor_marker_present==FALSE)
        {
            output.list=list("Sample info"=output.table.sample.info,"Panel specification"=output.table.panel,"Phenotypes specification"=output.table.phenotypes,"Tissue segmentation"=output.table.tissue.segmentation,"Marker thresholding (Total)"=output.table.single.marker.total,"Phenotypes (Total)"=output.table.phenotypes.total,"Other phenotypes (Total)"=output.table.other.phenotypes.total)
        }
        else if(flag_other_tissue)
        {
            output.list=list("Sample info"=output.table.sample.info,"Panel specification"=output.table.panel,"Phenotypes specification"=output.table.phenotypes,"Tissue segmentation"=output.table.tissue.segmentation,"Marker thresholding (Total)"=output.table.single.marker.total,"Markers thresholding (Stroma)"=output.table.single.marker.stroma,"Marker thresholding (Tumor)"=output.table.single.marker.tumor,"Marker thresholding (Other)"=output.table.single.marker.other,"Phenotypes (Total)"=output.table.phenotypes.total,"Phenotypes (Stroma)"=output.table.phenotypes.stroma,"Phenotypes (Tumor)"=output.table.phenotypes.tumor,"Phenotypes (Other)"=output.table.phenotypes.other,"Other phenotypes (Total)"=output.table.other.phenotypes.total,"Other phenotypes (Stroma)"=output.table.other.phenotypes.stroma,"Other phenotypes (Tumor)"=output.table.other.phenotypes.tumor,"Other phenotypes (Other)"=output.table.other.phenotypes.other)
        }
        else
        {
            output.list=list("Sample info"=output.table.sample.info,"Panel specification"=output.table.panel,"Phenotypes specification"=output.table.phenotypes,"Tissue segmentation"=output.table.tissue.segmentation,"Marker thresholding (Total)"=output.table.single.marker.total,"Markers thresholding (Stroma)"=output.table.single.marker.stroma,"Marker thresholding (Tumor)"=output.table.single.marker.tumor,"Phenotypes (Total)"=output.table.phenotypes.total,"Phenotypes (Stroma)"=output.table.phenotypes.stroma,"Phenotypes (Tumor)"=output.table.phenotypes.tumor,"Other phenotypes (Total)"=output.table.other.phenotypes.total,"Other phenotypes (Stroma)"=output.table.other.phenotypes.stroma,"Other phenotypes (Tumor)"=output.table.other.phenotypes.tumor)
        }
        write_xlsx(output.list,path=filename) 
    }
}
##############################
##save cells properties table
##############################
if(flag_tables)
{
    ##convert to micron & mm^2
    Precision=-floor(log10(convert.image.to.slide.length(1,image.info)))
    SquarePrecision=-floor(log10(convert.image.to.slide.length(1,image.info)**2))
    convert.position.x=function(x,image.info){round(convert.image.to.slide.position.x(x,image.info),digits=Precision)}
    convert.position.y=function(x,image.info){round(convert.image.to.slide.position.y(x,image.info),digits=Precision)}
    convert.length=function(x,image.info){round(convert.image.to.slide.length(x,image.info),digits=Precision)}
    convert.area=function(x,image.info){round(convert.image.to.slide.area(x,image.info),digits=SquarePrecision)}

    ##columns region of interest
    output.table=data.all[excluded==FALSE][,
                                           .(cell.ID,
                                             nucleus.x=convert.position.x(nucleus.x,image.info),
                                             nucleus.y=convert.position.y(nucleus.y,image.info),
                                             cell.area=convert.area(area,image.info)
                                             )]
    ##add <channel>.score
    output.table=cbind(output.table,setnames(data.all[excluded==FALSE][,.SD,.SDcols=patterns("channel_.*score")],
                                             paste0(rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)],".score"),
                                             paste0(metadata[!metadata$channel%in%c(channel.dapi,channel.autofluorescence),"name"],".score")))
    ##add <channel>.score.normalized
    tmp=copy(data.all[excluded==FALSE][,.SD,.SDcols=patterns("channel_.*score")])
    for(col in colnames(tmp))
    {
        set(tmp,i=NULL,col,round(tmp[,col,with=FALSE]/metadata.channel.thresholding[gsub(".score$","",col),"threshold"],digits=4))
    }
    setnames(tmp,paste0(rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)],".score"),
             paste0(metadata[!metadata$channel%in%c(channel.dapi,channel.autofluorescence),"name"],".score.normalized"))
    output.table=cbind(output.table,tmp)

    output.table=cbind(output.table,data.all[excluded==FALSE][,.(tissue.type,
                                                                 phenotype=phenotype.raw
                                                                 ##phenotype.label
                                                                 )])
    if(!is.null(input.TLS))
        output.table=cbind(output.table,data.all[excluded==FALSE][,.(TLS.ID)])

    if(!is.null(input.ROI))
    {
        in.ROI=data.all[excluded==FALSE,.SD,.SDcols=patterns("^in.ROI.[0-9]+$")]
        setnames(in.ROI,paste0("in.ROI.",seq_along(regions.of.interest.labels)),paste0("in.ROI.",str_sanitize_path(tolower(regions.of.interest.labels))))
        output.table=cbind(output.table,in.ROI)
    }
    filename=paste0(outputdir,"/cells_properties.tsv")
    cat("creating",filename,"\n")
    fwrite(output.table,file=filename,sep="\t",na="NA",quote=FALSE,row.names=FALSE)
    gzip(filename,destname=paste(filename,"gz",sep="."),overwrite=TRUE)

    tmp.score=metadata.channel.thresholding[,]
    tmp.score$score.region=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\2",tmp.score$score.type)
    tmp.score$score.statistics=gsub("^(circular\\.[^.]*|[^.]*)\\.(nucleus|extended.nucleus|around.nucleus)$","\\1",tmp.score$score.type)
    ##reformat score.region
    tmp.score$score.region=gsub("^nucleus$","nucleus",tmp.score$score.region)
    tmp.score$score.region=gsub("^extended.nucleus$","extended nucleus",tmp.score$score.region)
    tmp.score$score.region=gsub("^around.nucleus$","around nucleus (doughnut)",tmp.score$score.region)
    ##reformat score.statistics
    tmp.score$score.statistics=gsub("circular\\.","encircling ",tmp.score$score.statistics)
    tmp.score$score.statistics=gsub("q050","median",tmp.score$score.statistics)
    tmp.score$score.statistics=gsub("q0*([1-9][0-9]*)","\\1 percentile",tmp.score$score.statistics)
    tmp.score$score.statistics=gsub("(^1| 1) ","\\1-st ",tmp.score$score.statistics)
    tmp.score$score.statistics=gsub("(^2| 2) ","\\1-nd ",tmp.score$score.statistics)
    tmp.score$score.statistics=gsub("([0-9]| [0-9]) ","\\1-th ",tmp.score$score.statistics)
    tmp.score=tmp.score[,c("score.statistics","score.region","threshold")]

    filename=paste0(outputdir,"/README.txt")
    cat("creating",filename,"\n")
    cat("cells_properties.tsv.gz: gzipped tab delimited file with columns\n",file=filename,sep="")
    cat(" - cell.ID: cell ID.\n",file=filename,append=TRUE,sep="")
    cat(" - nucleus.x: x coordinate of nucleus center in slide coordinate system (micrometer).\n",file=filename,append=TRUE,sep="")
    cat(" - nucleus.y: y coordinate of nucleus center in slide coordinate system (micrometer).\n",file=filename,append=TRUE,sep="")
    cat(" - cell.area: voronoi cell area (micrometer^2).\n",file=filename,append=TRUE,sep="")
    for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
        cat(" - ",metadata[f,"name"],".score: ",metadata[f,"name"]," score (statistics: ",tmp.score[f,"score.statistics"],", region: ",tmp.score[f,"score.region"],").\n",file=filename,append=TRUE,sep="")
    for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
        cat(" - ",metadata[f,"name"],".score.normalized: normalized score (",metadata[f,"name"],".score/",metadata[f,"name"],".threshold).\n",file=filename,append=TRUE,sep="")
    cat(" - tissue.type: tissue type.\n",file=filename,append=TRUE,sep="")
    cat(" - phenotype: phenotype.\n",file=filename,append=TRUE,sep="")
    ##cat(" - phenotype.label: phenotype label.\n",file=filename,append=TRUE,sep="")
    if(!is.null(input.TLS))
        cat(" - TLS.ID: ID of the TLS if the cell is in a TLS. NA if the cell is not in a TLS.\n",file=filename,append=TRUE,sep="")
    for(i in seq_along(regions.of.interest.labels))
        cat(" - in.ROI.",str_sanitize_path(tolower(regions.of.interest.labels[i])),": TRUE if nucleus center is inside region of interest ",i," (",regions.of.interest.labels[i],"), FALSE otherwise.\n",file=filename,append=TRUE,sep="")
    cat("\n",file=filename,append=TRUE,sep="")
    cat("\n",file=filename,append=TRUE,sep="")
    cat("Thresholds:\n",file=filename,append=TRUE,sep="")
    for(f in rownames(metadata)[!metadata$channel%in%c(channel.dapi,channel.autofluorescence)])
        cat(" - ",metadata[f,"name"],".threshold: ",tmp.score[f,"threshold"],"\n",file=filename,append=TRUE,sep="")

}
##############################
##clean
##############################
clean()
cat(paste0("[",format(Sys.time()),"] "),"Done\n")
